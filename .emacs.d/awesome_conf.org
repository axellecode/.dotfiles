#+TITLE: Emacs "generic" personal config
#+SUBTITLE: An org-mode config I use to deploy NixOS for third parties
#+AUTHOR: Kim ALLAMANDOLA

* EXWM | my Windows manager
Yes, Emacs can be a good windows manager. In the past I have used
few DEs and WMs but now I realize that all modern DE are CRAP. Way
to complex for what they delivery and limited in term of usability.
Moving windows around is not a productive or pleasant task, being
tied to a "layout style" like modern tiling WM is too rigid in any
non super-simple case and rearrenge windows around is simply hard
and frustrating. So EXWM: it mix the good idea of tiling WMs and
the flexibility of classic WM plus tons of other nice feature (like
"navigate" through different windows layout, even save them with a
name like Eclipse perspective. It's model root in the ancient Integra
the windows system of LispM and is more actual than ever.

The very first is to fullscreen Emacs since anything will live inside.
#+BEGIN_SRC emacs-lisp
(set-frame-parameter nil 'fullscreen 'fullboth)
#+END_SRC

Next it's time to load EXWM
#+BEGIN_SRC emacs-lisp
(use-package exwm
 :init
  (require 'exwm-config)
  (require 'exwm-systemtray)
  (setq exwm-systemtray-height 16)
  (exwm-systemtray-enable)

  (setq switch-window-input-style 'minibuffer
        exwm-workspace-number 4
        use-dialog-box nil
        exwm-floating-border-width 3
        exwm-floating-border-color "orange"
        exwm-workspace-show-all-buffers 't
        exwm-layout-show-all-buffers 't)

  (setq window-divider-default-right-width 1)
  (window-divider-mode)

  ;; few X applications badly set window title and class...
  (add-hook 'exwm-update-class-hook
          (lambda ()
            (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-class-name))))
  (add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))

 ;; WARNING :: use-package call is NOT CLOSED HERE!!!
#+END_SRC

And time to add few keybindings, WARNING: some are defined elseware in
the conf since they belong to specific Emacs packages. Also if you
want some global keybindings available also in X apps it have to be
defined as EXWM one with ~exwm-input-set-key~.
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-w") nil) ; unbind C-w before multi-key usage
  (exwm-input-set-key (kbd "C-w r") #'exwm-reset)
  (exwm-input-set-key (kbd "M-w") #'exwm-workspace-switch-to-buffer)

  ;; + Bind "s-0" to "s-9" to switch to the corresponding workspace.
  (dotimes (i 10)
    (exwm-input-set-key (kbd (format "M-%d" i))
                      `(lambda ()
                         (interactive)
                         (exwm-workspace-switch-create ,i))))

  (exwm-input-set-key (kbd "M-|")
                    (lambda (command)
                      (interactive (list (read-shell-command "$ ")))
                      (start-process-shell-command command nil command)))

  ;; turn off screen via xset XXX - agg. lo script
  (exwm-input-set-key (kbd "<print>")
      (lambda ()
        (interactive)
        (call-process-shell-command
         "/kim/env/script/dpms_off"
         nil nil nil) ))

  ;; turn off the local machine via shutdown -h now
  (exwm-input-set-key (kbd "S-<print>")
      (lambda ()
        (interactive)
        (call-process-shell-command
         "/kim/env/script/shutdown"
         nil nil nil) ))

  ;; to move a window from a worksplace (virtual desktop) to another
  (defun exwm-workspace-switch-to-window ()
    "Make the current Emacs window display another X window."
    (interactive)
    (let ((buffer (read-buffer "Switch to window: " nil t
                             (lambda (bufname)
                               (exwm--buffer->id
                                (cond
                                 ((listp bufname) (cdr bufname))
                                 (t (get-buffer bufname))))))))
    (when buffer
      (with-current-buffer buffer
        (when (and (eq major-mode 'exwm-mode)
                   (not (eq exwm--frame exwm-workspace--current)))
          (exwm-workspace-move-window exwm-workspace-current-index
                                      exwm--id))))))

  (defun exwm-input-line-mode ()
    "Set exwm window to line-mode and show mode line"
    (call-interactively #'exwm-input-grab-keyboard)
    (exwm-layout-show-mode-line))

  (defun exwm-input-char-mode ()
    "Set exwm window to char-mode and hide mode line"
    (call-interactively #'exwm-input-release-keyboard)
    (exwm-layout-hide-mode-line))

  (defun exwm-input-toggle-mode ()
    "Toggle between line- and char-mode"
    (with-current-buffer (window-buffer)
      (when (eq major-mode 'exwm-mode)
        (if (equal (second (second mode-line-process)) "line")
            (exwm-input-char-mode)
          (exwm-input-line-mode)))))
#+END_SRC

Simulation keys are a way to Emacs-yze bindings for X apps in a way that
a key sequence work both in Emacs and X apps.


Finally it's time to run EXWM
#+BEGIN_SRC emacs-lisp
  (exwm-enable)

)  ;; WARNING :: req-package call closed here!!!

(use-package exwm-x)
(use-package dmenu)
#+END_SRC

The rest of personal EXWM config is mostly bindings like
#+BEGIN_SRC emacs-lisp :tangle no
;; EXWM bindings instead of
(exwm-input-set-key (kbd "<XF86AudioStop>") #'linkmarks-select)

;; classic Emacs-only bindings
(global-set-key (kbd "<XF86AudioStop>") 'linkmarks-select)
#+END_SRC

* Init.el basic
I use plain classic init.el to tangle config from this file.
#+BEGIN_SRC emacs-lisp :tangle no
;; ============================================================================
;; Small init.el file that load the rest of the config from emacs.org file in
;; the same directory...
;; Author: Kim Allamandola <kim@kfx.fr>   License: GNU GPLv3
;; ============================================================================

;; with package.el (Emacs built-in) I set a list of pkg I'd like to install
(require 'package)
(setq my-package-list '(org))

;; I set package's sources
(setq package-archives
'(
   ("org" . "http://orgmode.org/elpa/")
   ("gnu" . "http://elpa.gnu.org/packages/")
   ("melpa" . "https://melpa.org/packages/")
))

;; initialyze local repo
(package-initialize)
(require 'use-package)
(setq use-package-always-ensure t)

;; update (if needed) package list
(unless package-archive-contents (package-refresh-contents))

;; bound org to a specific repo (due to MELPA naming scheme)
(when (boundp 'package-pinned-packages)
  (setq package-pinned-packages '( (org . "org") )))

;; and now I can install pkgs listed above
(dolist (package my-package-list)
  (unless (package-installed-p package)
    (package-install package)))

;; then I have org-mode, it's time to load the org file
(require 'org)
(require 'org-install)
(require 'ob-tangle)
(org-babel-load-file "./emacs.org")
(setq custom-file "./custom.el")
(load custom-file)
(put 'erase-buffer 'disabled nil)

;; Local Variables:
;; byte-compile-warnings: (not free-vars callargs unresolved)
;; End:

#+END_SRC

* Basic setup
Just to start a bunch of things, the VERY first is a big UI declutter
#+BEGIN_SRC emacs-lisp
(set-scroll-bar-mode nil) ; no scrollbar
(tool-bar-mode -1) ; and no toolbar also
(menu-bar-mode -1) ; and no menu bar
(fringe-mode 1) ; 1 pixel fringes
(column-number-mode)
(size-indication-mode)
(footnote-mode)

(setq switch-window-input-style 'minibuffer
      use-dialog-box nil
      initial-major-mode 'org-mode
      major-mode 'org-mode
      initial-scratch-message ""
      read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t
      mouse-yank-at-point t
      inhibit-startup-screen t
      package-check-signature nil
      load-prefer-newer t
      window-divider-default-right-width 1)
(window-divider-mode)
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

CUA mode is contain a bunch of nice stuff (like rectangular operations)
and add Windows-like cut/copy/paste support
#+BEGIN_SRC emacs-lisp
(cua-mode)
(setq cua-auto-tabify-rectangles nil)
(transient-mark-mode 1)
(setq cua-keep-region-after-copy t)
#+END_SRC

Another bunch of misc basic stuff
#+BEGIN_SRC emacs-lisp
(global-font-lock-mode 1)
(setq font-lock-maximum-decoration t)
(setq ps-paper-type 'a4
      ps-landscape-mode nil
      ps-use-face-background t)
(setq sentence-end-double-space nil)

(mouse-wheel-mode t)
(setq-default tab-width 2)
(setq-default indent-tabs-mode nil)
(show-paren-mode 1)
(add-hook 'write-file-hooks 'delete-trailing-whitespace)
(setq-default fill-column 73)
(add-hook 'text-mode-hook 'turn-on-auto-fill)

;; save&restore windows layout in a frame
;; use C-c ← to undo (restore windows previous config aka winner-undo)
;;     C-c → to redo (restore wondos ante-restore config aka winner-redo)
(winner-mode 1)

(setq display-time-day-and-date t)
(setq display-time-24hr-format t)
(setq display-time-default-load-average nil)

(display-time-mode t)

(setq  rmail-file-name "/tmp/RMAIL")
#+END_SRC

Another thing to tweak is a small change in Emacs backup handling for edited files
I do NOT like '~' filenames nor other stuff on my filesystem, but I do like to
being able to recovery in case of a crash so I move anything to /tmp
#+BEGIN_SRC emacs-lisp
(defvar user-temporary-file-directory
  (concat temporary-file-directory user-login-name "/"))
(make-directory user-temporary-file-directory t)
(setq backup-by-copying t)
(setq backup-directory-alist
      `(("." . ,user-temporary-file-directory)
        (,tramp-file-name-regexp nil)))
(setq auto-save-list-file-prefix
      (concat user-temporary-file-directory ".auto-saves-"))
(setq auto-save-file-name-transforms
      `((".*" ,user-temporary-file-directory t)))
(setq make-backup-files nil)
#+END_SRC

Ok, so we can start with few packages, the first to humanyze buffer names
#+BEGIN_SRC emacs-lisp :tangle no
(use-package uniquify
  :init
    (setq uniquify-buffer-name-style 'forward
          uniquify-separator "/"
          uniquify-after-kill-buffer-p t    ; rename after killing uniquified
          uniquify-ignore-buffers-re "^\\*")) ; don't muck with special buffers
#+END_SRC

Than it's time to have a good modeline, doom-modeline from doom-emacs config is
IMVHO one of the best, powerline (ported from VIM) is another really good one.
#+BEGIN_SRC emacs-lisp
(use-package doom-modeline
  :hook (after-init . doom-modeline-init)
  :init
   (setq doom-modeline-height 19))
#+END_SRC

A small pkg set
#+BEGIN_SRC emacs-lisp
(use-package rainbow-mode)
(use-package hl-line)
(use-package ace-window)
(use-package pdfgrep)
(use-package olivetti
 :init (setq olivetti-body-width 80)
 :hook (text-mode-hook . turn-on-olivetti-mode))
(use-package ix)
(use-package imgbb)
(use-package ag)
(use-package wgrep)
(use-package wgrep-ag
  :init (require 'wgrep-ag) )

(use-package proced
  :config
    (defun local-proced-settings ()
      "Personal proced settings"
      (proced-toggle-auto-update 1))
    (add-to-list 'same-window-buffer-names "*Proced*")
    (add-hook 'proced-mode-hook #'local-proced-settings))

(use-package download-region)
(use-package figlet)

(use-package diminish
  :config
    (diminish 'auto-fill-function))

(use-package char-menu
  :bind (("<pause>" . char-menu))
  :config
    (setq char-menu '("€" "²" "₂"  "°" "℃" "ù" "à" "è" "é" "ì" "ò"
                      "œ" "Œ" "À" "ç" "Ç" "ô" "È" "«»"
	             (" Typography" "•" "©" "†" "‡" "°" "·" "§" "№" "★")
	             (" Math"       "≈" "≡" "≠" "∞" "×" "±" "∓" "÷" "√")
		     (" Superscript" "⁰" "¹" "²" "³" "⁴" "⁵" "⁶" "⁷" "⁸" "⁹")
		     (" Subscript"   "₀" "₁" "₂" "₃" "₄" "₅" "₆" "₇" "₈" "₉")
                     (" Arrows"     "←" "→" "↑" "↓" "⇐" "⇒" "⇑" "⇓")
                     (" Greek"      "α" "β" "δ" "ε" "λ" "μ" "ν" "π" "ρ"
			                        "σ" "τ" "υ" "φ" "χ" "ω"))))

(use-package json-mode)
(use-package nix-mode
  :config
    (add-to-list 'auto-mode-alist '("\\.nix\\'" . nix-mode)))

(use-package idle-highlight-mode)
(use-package golden-ratio
  :diminish golden-ratio-mode
  :init
    (golden-ratio-mode 1)
    (setq golden-ratio-auto-scale t))

(use-package idomenu
  :bind ("C-c i" . idomenu))

(use-package macro-math)
(use-package scratch-ext)
(use-package scratches)
(use-package vlf)

(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
         (prog-mode . goto-address-prog-mode)
         (eshell-mode . goto-address-mode)
         (shell-mode . goto-address-mode))
  :bind (:map goto-address-highlight-keymap
          ("<RET>" . goto-address-at-point)
          ("M-<RET>" . newline))
  :commands (goto-address-prog-mode goto-address-mode))

(use-package undo-tree
  :diminish undo-tree-mode
  :init
    (global-undo-tree-mode 1)
    (defalias 'redo 'undo-tree-redo)
  :bind
    ( ("<C-z>" . undo)
      ("<C-y>" . redo) ) )

(use-package minibuffer-complete-cycle
  :init (setq minibuffer-complete-cycle t))

(use-package expand-region
  :bind (("C-." . er/expand-region)))

(use-package autopair
  :diminish autopair-mode
  :init (autopair-global-mode))

(use-package move-dup
  :config
    (global-move-dup-mode))

(use-package move-text)

(use-package smooth-scrolling
  :init
    (setq smooth-scroll-margin 3
          scroll-conservatively 9999
          scroll-preserve-screen-position t))

(add-hook 'shell-mode-hook
 (lambda ()
       (setq show-trailing-whitespace nil)
       (column-marker 0)
       (autopair-mode -1)))

(use-package iedit
  :bind (("s-," . iedit-mode)))

(use-package rainbow-delimiters
  :hook (prog-mode-hook . rainbow-delimiters-mode))
#+END_SRC

* Basic keybindings
This is a first batch of personal bindings, some are setted by use-package so
here is not the entire picture...
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-M-k") 'kill-this-buffer)
(global-set-key (kbd "C-M-S-k") 'kill-buffer-and-window)
(global-set-key (kbd "M-s") 'save-buffer)

;; stealed from https://ambrevar.xyz/emacs2/
(defun ambrevar/switch-to-last-buffer ()
  "Switch to last open buffer in current window."
  (interactive)
  (switch-to-buffer (other-buffer (current-buffer) 1)))
(global-set-key (kbd "<f1>") 'ambrevar/switch-to-last-buffer)

(global-set-key (kbd "<f2>") 'delete-other-windows)
(global-set-key (kbd "<f3>") 'other-window)
(global-set-key (kbd "<f4>") 'split-window-below)
(global-set-key (kbd "<f5>") 'split-window-right)
(global-set-key (kbd "<f9>") 'eshell)
(global-set-key (kbd "M-w") 'switch-to-buffer)
(global-set-key (kbd "C-M-w") 'ace-window)

(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(global-set-key (kbd "C-q") nil) ; unbind C-q before multi-key usage
(global-set-key (kbd "C-q q") 'kill-whole-line)
(global-set-key (kbd "C-q i") 'quoted-insert)
(defun backward-kill-line (arg)
  "Kill ARG lines backward."
  (interactive "p")
  (kill-line (- 1 arg)))
(global-set-key (kbd "C-q ^") 'backward-kill-line)
(global-set-key (kbd "C-q h") '(lambda () (interactive) (kill-line 0)) )
(global-set-key (kbd "C-q e") 'kill-line) ;; and from-cursor-to-$
(global-set-key (kbd "C-q w") 'kill-word) ;; and single word next to point
(global-set-key (kbd "C-q <deletechar>") 'backward-kill-word)

(global-set-key (kbd "<C-M-left>") 'shrink-window-horizontally)
(global-set-key (kbd "<C-M-right>") 'enlarge-window-horizontally)
#+END_SRC

* bookmarks
One super-nice feature of Emacs is bookmark support: we can bookmark any file
or directory, including with tram stuff on other machines accessible via ssh,
ftp, ... any tramp-supported method.
#+BEGIN_SRC emacs-lisp
(setq bookmark-default-file "~/.emacs.d/bookmarks")
(setq bookmark-save-flag 1)
(lambda () (interactive)
  (bookmark-load "~/.emacs.d/bookmarks"))

(global-set-key (kbd "C-S-b") 'bookmark-bmenu-list)
(global-set-key (kbd "C-b") 'bookmark-jump)
(global-set-key (kbd "C-M-b") 'bookmark-set)

#+END_SRC

* spell checking stuff
#+BEGIN_SRC emacs-lisp
(use-package auto-dictionary
  :hook ((message-mode-hook . adict-guess-dictionary)
         (LaTeX-mode-hook . adict-guess-dictionary)
         (text-mode-hook  . adict-guess-dictionary)))

(use-package flycheck
  :diminish flycheck-mode
  :hook
    ((after-init . global-flycheck-mode)
     (text-mode-hook . flycheck-mode)
     (prog-mode-hook . flycheck-mode))
  :config
    (setq flycheck-indication-mode 'right-fringe
          flycheck-check-syntax-automatically '(save mode-enabled)
          flycheck-emacs-lisp-load-path 'inherit))

(use-package flycheck-cython)
(use-package flycheck-ledger)
(use-package flycheck-yamllint)
(use-package avy-flycheck
  :hook (global-flycheck-mode . avy-flycheck-setup))

(if (display-graphic-p)
  (use-package flycheck-pos-tip
    :hook (global-flycheck-mode . flycheck-pos-tip-mode)
    :config (setq flycheck-pos-tip-timeout 30))
  (use-package flycheck-popup-tip
    :hook (global-flycheck-mode . flycheck-popup-tip-mode)))

#+END_SRC

* window/buffer navigation helpers
A small collection of pkgs to navigate and handle windows/buffers
#+BEGIN_SRC emacs-lisp
(use-package buffer-move
  :bind (("<C-S-up>"    . buf-move-up)
         ("<C-S-down>"  . buf-move-down)
	 ("<C-S-left>"  . buf-move-left)
	 ("<C-S-right>" . buf-move-right)))

(use-package windmove
  :config
   (add-hook 'org-shiftup-final-hook 'windmove-up)
   (add-hook 'org-shiftleft-final-hook 'windmove-left)
   (add-hook 'org-shiftdown-final-hook 'windmove-down)
   (add-hook 'org-shiftright-final-hook 'windmove-right)
  :bind (("<C-up>"    . windmove-up)
         ("<C-down>"  . windmove-down)
         ("<C-left>"  . windmove-left)
         ("<C-right>" . windmove-right)))

(use-package ibuffer
  :init
    (defalias 'list-buffers 'ibuffer)
    (setq ibuffer-formats
      '((mark " "
              (modified)
	      " "
	      (name 40 40 :right :elide)
	      " "
	      (filename-and-process))
	(mark " "
	      (filename-and-process 70 70 :left :elide)
	      " "
	      name)))

    (setq ibuffer-saved-filter-groups
          (list
            (cons "files"
	          (append
	            '(("dired" (mode . dired-mode))
	              ("term" (mode . term-mode))
	              ("emacs" (name . "\*.*\*")))))))

    (add-hook 'ibuffer-mode-hook
      (lambda ()
        (ibuffer-switch-to-saved-filter-groups "files")))

    (setq ibuffer-show-empty-filter-groups nil))
#+END_SRC

* small function collection
#+BEGIN_SRC emacs-lisp
(defun unfill-region (beg end)
  "Unfill the region, joining text paragraphs into a single
  logical line.  This is useful, e.g., for use with
  `visual-line-mode'."
    (interactive "*r")
      (let ((fill-column (point-max)))
          (fill-region beg end)))

(defun copy-file-path-to-clipboard ()
  "Put the current file name on the clipboard"
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                       default-directory
                       (buffer-file-name))))
                       (when filename
		       (with-temp-buffer
		       (insert filename)
		       (clipboard-kill-region (point-min) (point-max)))
                       (message filename))))

;; personal function to do basic math in buffer; usage is simple, type an
;; algebraic expression in M-x calc algebraic style, select it and run
;; eval-math-expr. Result are appended at the end of the region.
(defun eval-math-expr (beg end)
  (interactive "r")
  (require 'calc)
  (let ((result
            (calc-eval
              (buffer-substring beg end))))
    (save-excursion
      (goto-char end) (insert " => " result))))
(global-set-key (kbd "M-m") 'eval-math-expr)

;; nice to byte compile from http://goo.gl/4JBKbZ
(defun byte-compile-init-dir ()
  "Byte-compile all your dotfiles."
  (interactive)
  (byte-recompile-directory user-emacs-directory 0))

(defun remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))
            nil
            t))

(add-hook 'emacs-lisp-mode-hook 'remove-elc-on-save)
#+END_SRC

* themes
#+BEGIN_SRC emacs-lisp
(use-package ample-theme
  :init
    (if (display-graphic-p)
      ;; on X11 ample looks better IMO
      (progn (load-theme 'ample t t)
        (load-theme 'ample-flat t t)
        (enable-theme 'ample) )
      ;; in CLI ample-flat is better
      (progn (load-theme 'ample t t)
        (load-theme 'ample-flat t t)
        (enable-theme 'ample-flat) )))
#+END_SRC

* dired
Dired is the Emacs file manager, sometime a bit raw but usefull
especially for many file operation stuff, mass-renaming etc
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<f8>") 'dired)
(use-package ranger)

;; toggle hide/show dotfiles
(define-key dired-mode-map (kbd "M-h")
        (function
         (lambda nil (interactive) (dired-hide-dotfiles-mode))))

(use-package async
  :init
    (eval-after-load 'dired '(dired-async-mode))
    (setq dired-dwim-target t))

(use-package dired-rainbow)
(use-package dired-dups)
(use-package dired-filetype-face)
(use-package dired-hide-dotfiles)
(use-package dired-ranger)
(use-package dired-single)
(use-package dired-collapse)
(use-package direx)
(use-package dired-k)
(use-package dired-narrow)
(use-package diredfl
  :hook (dired-mode-hook . diredfl-mode))

;; hintting i on a dir in dired expand dir content in a tree-like fascion
;; in the current buffer, hitting ; remove it. Useful to quickly see dir
;; contents, having "at a glance" view or quickly copy/paste files.
(use-package dired-subtree
  :bind
    (:map dired-mode-map
      ("i" . dired-subtree-insert)
      (";" . dired-subtree-remove)))

(use-package pcre2el
  :config (pcre-mode)
  :bind (:map dired-mode-map
         ("/" . dired-mark-files-regexp))  )

(use-package dired-launch
  :init (dired-launch-enable)
  :config
    (setq dired-launch-default-launcher '("xdg-open"))
    (define-key dired-launch-mode-map (kbd "l") 'dired-launch-command)

    (setf dired-launch-extensions-map
    (list
      '("odt" ("swriter"))
      '("ods" ("scalc"))
      '("xls" ("scalc"))
      '("xlsx" ("scalc"))
      '("flv" ("mplayer"))
      '("mp4" ("mplayer"))
      '("mp3" ("mplayer"))
      '("ogg" ("mplayer"))
      '("avi" ("mplayer"))
      '("mkv" ("mplayer"))
      '("ogv" ("mplayer"))
      '("mpg" ("mplayer"))
      '("mpeg" ("mplayer"))
      '("3gp" ("mplayer"))
      '("3gpp" ("mplayer"))
      '("mov" ("mplayer"))
      '("pdf" ("evince"))
      '("txt" ((find-file)))))
  :hook (dired-mode-hook . dired-launch-mode) )

(use-package dired-efap
  :bind (:map dired-mode-map
        ("r" . dired-efap)))

(use-package all-the-icons-dired
  :init
    (add-hook 'dired-mode-hook 'all-the-icons-dired-mode))

(setq dired-listing-switches "-alh --group-directories-first"
        wdired-allow-to-change-permissions t)

(use-package dired-single
  :init
    (defun my-dired-init ()
     "Bunch of stuff to run for dired, either immediately or when it's
      loaded."
     ;; <add other stuff here>
     (define-key dired-mode-map [return] 'dired-single-buffer)
     (define-key dired-mode-map [mouse-1] 'dired-single-buffer-mouse)
     (define-key dired-mode-map "^"
     (function
         (lambda nil (interactive) (dired-single-buffer "..")))))
     ;; if dired's already loaded, then the keymap will be bound
     (if (boundp 'dired-mode-map)
       (my-dired-init)
     (add-hook 'dired-load-hook 'my-dired-init)))

(define-key dired-mode-map (kbd "w") 'wdired-change-to-wdired-mode)
(add-hook 'dired-mode-hook 'auto-revert-mode)
(setq dired-recursive-deletes 'always
      dired-recursive-copies 'always)
#+END_SRC

A nice function stealed from I do not remember where to create
empty files in dired. By default to create a dir we hit '+',
I add '_' (next to + on US/International kbd) to create files
in the versy same way
#+BEGIN_SRC emacs-lisp
(eval-after-load 'dired
  '(progn
       (define-key dired-mode-map (kbd "_") 'my-dired-create-file)
            (defun my-dired-create-file (file)
	           "Create a file called FILE.
		           If FILE already exists, signal an error."
			          (interactive
				          (list (read-file-name "Create file: " (dired-current-directory))))
					         (let* ((expanded (expand-file-name file))
						               (try expanded)
							                     (dir (directory-file-name (file-name-directory expanded)))
									                   new)
											            (if (file-exists-p expanded)
(error "Cannot create file %s: file exists" expanded))
         ;; Find the topmost nonexistent parent dir (variable `new')
	          (while (and try (not (file-exists-p try)) (not (equal new try)))
		             (setq new try
			                      try (directory-file-name (file-name-directory try))))
					               (when (not (file-exists-p dir))
						                  (make-directory dir t))
								           (write-region "" nil expanded t)
									            (when new
										               (dired-add-file new)
											                  (dired-move-to-filename))))))
#+END_SRC

* Ivy/Counsel/Swiper/Avy setup
Ivy/Counsel/Swiper are the best completion solution for Emacs, by Abo-Abo
e others, a bit less complete than Helm but really *super* juicy.
#+BEGIN_SRC emacs-lisp
(use-package counsel
  :diminish ivy-mode counsel-mode
  :init
    (ivy-mode 1)
    (counsel-mode)
    (setq ivy-use-virtual-buffers t)
    (define-key ivy-minibuffer-map (kbd "TAB") 'ivy-alt-done)

  :bind (("C-s" . swiper)
         ("M-x" . counsel-M-x)
         ("<menu>" . counsel-M-x)
         ("C-M-u" . counsel-unicode-char)
         ("C-c M-x" . execute-extended-command)))

(use-package ivy
  :custom
    (ivy-count-format "(%d/%d) ")
    (ivy-display-style 'fancy)
    (ivy-use-virtual-buffers t))

(use-package ivy-explorer
  :config
    (ivy-explorer-mode 1)
    (counsel-mode 1))

(use-package ivy-rich
  :custom
    (ivy-virtual-abbreviate 'full
     ivy-rich-switch-buffer-align-virtual-buffer t
     ivy-rich-path-style 'abbrev)
  :config
    (ivy-set-display-transformer 'ivy-switch-buffer
     'ivy-rich-switch-buffer-transformer))

(use-package avy
  :bind (("C-S-l" . avy-goto-line)
	 ("C-S-w" . avy-goto-word-1)
	 ("C-S-c" . avy-goto-char)))

(use-package all-the-icons-ivy
  :init
    (all-the-icons-ivy-setup))

(use-package counsel-world-clock)
#+END_SRC

* Tramp
Finally tramp (builtin) for edit stuff via ssh
#+BEGIN_SRC emacs-lisp
(require 'tramp)
(setq tramp-default-method "sshx")
(use-package auto-sudoedit
  :init
(use-package counsel-tramp)
    (auto-sudoedit-mode 1) )
#+END_SRC

* Company
IMO the best completion-at-point solution for Emacs, perhaps with a bit less stuff
than AutoComplete (AC) but far lighter, simple and effective
#+BEGIN_SRC emacs-lisp
(use-package company
  :diminish company-mode
  :init (global-company-mode)
  :config
    (progn (setq
       company-idle-delay 0.2
       company-show-numbers nil
       company-minimum-prefix-length 2
       company-selection-wrap-around t
       company-tooltip-align-annotations t
       company-dabbrev-downcase nil
       company-dabbrev-other-buffers t
       company-auto-complete nil
       company-dabbrev-code-other-buffers 'all
       company-dabbrev-code-everywhere t
       company-dabbrev-code-ignore-case t)
    (bind-key [remap completion-at-point] #'company-complete company-mode-map)
    ); progn)
    ;; stealed from https://oremacs.com/2017/12/27/company-numbers/
    (setq company-show-numbers t)
    (let ((map company-active-map))
    (mapc
       (lambda (x)
         (define-key map (format "%d" x) 'ora-company-number))
       (number-sequence 0 9))
       (define-key map " " (lambda ()
                             (interactive)
                             (company-abort)
       (self-insert-command 1)))
      (define-key map (kbd "<return>") nil))
     (defun ora-company-number ()
       "Forward to `company-complete-number'.
       Unless the number is potentially part of the candidate.
       In that case, insert the number."
         (interactive)
	 (let* ((k (this-command-keys))
	 (re (concat "^" company-prefix k)))
	 (if (cl-find-if (lambda (s) (string-match re s))
		                    company-candidates)
	 (self-insert-command 1)
          (company-complete-number (string-to-number k)))))

    (add-hook 'eshell-mode-hook
      (lambda ()
        (define-key eshell-mode-map (kbd "<tab>")
	(lambda () (interactive) (pcomplete-std-complete))))))

(use-package company-shell
  :config
    (add-to-list 'company-backends '(company-shell
                                     company-shell-env
                                     company-fish-shell)))

(use-package company-auctex
  :config (progn
    (setq company-math-allow-latex-symbols-in-faces t)
    (company-auctex-init)))

(use-package company-quickhelp
  :config (company-quickhelp-mode 1))

(use-package company-nixos-options)

(use-package company-flx
  :config
    (company-flx-mode +1))

(use-package company-box
  :hook (company-mode . company-box-mode))

(use-package company-bibtex)
(use-package company-math)
#+END_SRC

* Yasnippet
The best snippet solution we have...
#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :diminish yas-minor-mode
  :init
    (yas-global-mode 1)
    (require 'yasnippet)
    (setq yas-snippet-dirs (append yas-snippet-dirs
    '("~/.emacs.d/snippets")))
    (yas-reload-all)
    (add-hook 'prog-mode-hook 'yas-minor-mode)
    (add-hook 'ess-mode-hook 'yas-minor-mode)
    (add-hook 'org-mode-hook 'yas-minor-mode)
    ;;(add-hook 'notmuch-message-mode 'yas-minor-mode)

    (defadvice yas/insert-snippet (around use-completing-prompt activate)
      "Use `yas/completing-prompt' for `yas/prompt-functions' but only here..."
      (let ((yas-prompt-functions '(yas/completing-prompt))) ad-do-it))

  :bind (("<C-tab>" . yas-expand)
         ("C-<"     . yas-insert-snippet)))

(use-package yasnippet-snippets
  :config (yasnippet-snippets-initialize))

(use-package auto-yasnippet
  :bind (("s-<f1>" . aya-create)
         ("s-<f2>" . aya-expand)
         ("H-<f1>" . aya-create)
         ("H-<f2>" . aya-expand)))
#+END_SRC

* Skeletor
Skeletor is a sort of companion to Yasnippet. While Yasnippet complete with
snippets inside a text buffer Skeletor create directory trees where you
want copying a template and do further action afterword.
#+BEGIN_SRC emacs-lisp
(use-package skeletor
  :config
    (setq skeletor-user-directory "~/.emacs.d/skeletor_tmpl"
          skeletor-init-with-git nil)

    (skeletor-define-template "slide-reveal"
       :no-license? t
       :title "Org-mode Reveal.js slides template")

    (skeletor-define-template "slide-beamer"
       :no-license? t
       :title "Org-mode Beamer slides template")

    (skeletor-define-template "ltr-IT"
       :no-license? t
       :title "Lettera LaTeX italiana"))

#+END_SRC

* Org-mode
This is The Big One™ package so the big one config... I try to split it in
sensible manner but it's still a bit confused...

** Download and attachments setup
A series of packages to download and attach stuff in org files, useful
sometime to download contents on their personal machine to make sure
it will be available in the future.
#+BEGIN_SRC emacs-lisp
(use-package org-download)
(use-package org-board)
#+END_SRC

** Keybindings
Org-mode related keybindigs
To have context-sensitive keybindings I steal a bit of lisp from Tassilo Horn
original code here: http://paste.lisp.org/display/304865
#+BEGIN_SRC emacs-lisp
(defmacro th/define-context-key (keymap key dispatch)
  `(define-key ,keymap ,key
  `(menu-item "context-key" ignore
    :filter ,(lambda (&optional ignored) ,dispatch))))

;; M-<left>/M-<right>/M-<up>/M-<down> in tables move columns/row
;; as expected, in org-headlines instead move headline up/down or
;; promote/demote.
(th/define-context-key org-mode-map
(kbd "M-<left>")
(when (org-at-table-p) 'org-table-move-column-left))

(th/define-context-key org-mode-map
(kbd "M-<right>")
(when (org-at-table-p) 'org-table-move-column-right))

(th/define-context-key org-mode-map
(kbd "M-<up>")
(when (org-at-table-p) 'org-table-move-row-up))

(th/define-context-key org-mode-map
(kbd "M-<down>")
(when (org-at-table-p) 'org-table-move-row-down))

;; -----

(th/define-context-key org-mode-map
(kbd "M-<down>")
(when (org-at-heading-p) 'org-move-subtree-down))

(th/define-context-key org-mode-map
(kbd "M-<up>")
(when (org-at-heading-p) 'org-move-subtree-up))

(th/define-context-key org-mode-map
(kbd "M-<left>")
(when (org-at-heading-p) 'org-do-promote))

(th/define-context-key org-mode-map
(kbd "M-<right>")
(when (org-at-heading-p) 'org-do-demote))

(th/define-context-key org-mode-map
(kbd "M-S-<right>")
(when (org-at-heading-p) 'org-demote-subtree))

(th/define-context-key org-mode-map
(kbd "M-S-<left>")
(when (org-at-heading-p) 'org-promote-subtree))

(th/define-context-key org-mode-map
(kbd "C-S-x")
(when (org-at-heading-p) 'org-cut-subtree))

(th/define-context-key org-mode-map
(kbd "C-S-c")
(when (org-at-heading-p) 'org-copy-subtree))

(th/define-context-key org-mode-map
(kbd "C-S-v")
(when (org-at-heading-p) 'org-paste-subtree))

(define-key org-mode-map (kbd "C-M-|") 'org-table-create-or-convert-from-region)

(define-key org-mode-map (kbd "C-S-r") 'org-refile)
(define-key org-mode-map (kbd "C-S-s") 'org-schedule)
(define-key org-mode-map (kbd "C-S-d") 'org-deadline)
(define-key org-mode-map (kbd "C-S-t") 'org-todo)
(define-key org-mode-map (kbd "C-S-a") 'org-org-archive-subtree)
#+END_SRC

** Org-related pkgs
#+BEGIN_SRC emacs-lisp
(use-package crm) ;; tags w/C-c C-q (org-set-tags-command)
;; few extra org-exporter
(require 'ox-html)
(require 'ox-ascii)
(require 'org-mouse)

(require 'org-indent)
(setq org-hide-leading-stars nil
      org-startup-indented t)

(use-package ox-html5slide)
(use-package ox-impress-js)
(use-package ox-asciidoc)
(use-package ox-clip)
(use-package ox-epub)
(use-package ox-pandoc)
(use-package ox-rst)

(use-package org-bullets
  :commands (org-bullets-mode)
  :init (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))

(require 'ox-latex)
(add-to-list 'org-latex-packages-alist '("" "minted"))
(setq org-latex-listings 'minted)
(setq org-latex-pdf-process
  '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
    "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
    "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))

(setq org-latex-create-formula-image-program 'imagemagick)
(setq org-format-latex-options (plist-put org-format-latex-options :scale 2.0))
(add-to-list 'org-latex-packages-alist '("AUTO" "babel"))
#+END_SRC

** org-agenda
#+BEGIN_SRC emacs-lisp
(require 'org-agenda)
(setq org-agenda-files '("~/org/agenda.org" "~/.emacs.d/agenda"))
(setq diary-file "~/.emacs.d/agenda/diary")
(setq calendar-week-start-day 1
      calendar-day-name-array ["Domenica"
                               "Lunedì"
			       "Martedì"
			       "Mercoledì"
			       "Giovedì"
			       "Venerdì"
			       "Sabato"]
      calendar-month-name-array ["Gennaio"
                                 "Febbraio"
                                 "Marzo"
                                 "Aprile"
                                 "Maggio"
                                 "Giugno"
                                 "Luglio"
                                 "Agosto"
                                 "Settembre"
                                 "Ottobre"
                                 "Novembre"
                                 "Dicembre"])

(setq solar-n-hemi-seasons '("Inizio primavera"
                             "Inizio estate"
                             "Inizio autunno"
                             "Inizio inverno"))

(setq feste-fr-it
  '((holiday-fixed 1 1 "Jour de l'an/Capodanno")
  (holiday-fixed 1 6 "Befana")
  (holiday-fixed 2 14 "San Valentino")
  (holiday-fixed 4 25 "Liberazione")
  (holiday-fixed 5 1 "Fête du travail")
  (holiday-fixed 5 8 "Victoire 1945")
  (holiday-fixed 6 2 "Festa della Repubblica")
  (holiday-fixed 6 21 "Fête de la musique")
  (holiday-fixed 7 14 "Fête nationale")
  (holiday-fixed 8 15 "Assomption/Ferragosto")
  (holiday-fixed 11 1 "Toussaint")
  (holiday-fixed 11 11 "Armistice 18")
  (holiday-fixed 12 25 "Noël/Natale")
  (holiday-fixed 12 26 "Santo Stefano")
  (holiday-easter-etc 1 "Lundi de Pâques")
  (holiday-easter-etc 39 "Ascension")
  (holiday-easter-etc 50 "Lundi de Pentecôte")))
(setq calendar-holidays (append feste-fr-it))

(setq calendar-week-start-day 1
      calendar-mark-holidays-flag t)

(setq calendar-time-display-form
      '(24-hours ":" minutes (and time-zone (concat " (" time-zone ")"))))

(add-hook 'calendar-load-hook
           (lambda ()
	     (calendar-set-date-style 'european)))

(setq org-agenda-restore-windows-after-quit 1
      org-agenda-include-diary t
      calendar-latitude 43.7
      calendar-longitude -6.6)

(require 'solar)

(defun solar-sunrise-string (date &optional nolocation)
  "String of *local* time of sunrise and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format
       "%s" ;;  "%s (%s h di luce)"
       (if (car l)
       (concat "A. " (apply 'solar-time-string (car l)))
        "no sunrise")
        (nth 2 l))))

(defun diary-sunrise ()
  "Local time of sunrise as a diary entry.
   Accurate to a few seconds."
   (or (and calendar-latitude calendar-longitude calendar-time-zone)
       (solar-setup))
       (solar-sunrise-string date))

(defun solar-sunset-string (date &optional nolocation)
  "String of *local* time of sunset and daylight on Gregorian DATE."
  (let ((l (solar-sunrise-sunset date)))
    (format "%s"
     (if (cadr l)
       (concat "T. " (apply 'solar-time-string (cadr l))) "no sunset")
	 (nth 2 l))))

(defun diary-sunset ()
  "Local time of sunset as a diary entry.
   Accurate to a few seconds."
  (or (and calendar-latitude calendar-longitude calendar-time-zone)
       (solar-setup)) (solar-sunset-string date))

;;Appointment Settings
(setq appt-issue-message t)
(add-hook 'diary-hook 'appt-make-list)
(setq appt-display-format 'window)
(appt-activate 1)

;; Fancy diary display
(add-hook 'diary-display-hook 'fancy-diary-display)
(add-hook 'list-diary-entries-hook 'sort-diary-entries t)

(global-set-key (kbd "<f7>") (lambda () (interactive)
          (progn (org-agenda nil "a") )) )

(global-set-key (kbd "S-<f7>") (lambda () (interactive)
          (progn (org-agenda nil "a") (org-agenda-day-view) )) )

(global-set-key (kbd "C-<f7>") (lambda () (interactive)
          (progn (org-agenda nil "a") (org-agenda-month-view) )) )
#+END_SRC

** org-alert (desktop notification for org-agenda events)
There are MANY option and ways, as usual for desktop notification,
many add audio notification via festival, others add mail notifications
having Emacs on some server etc. My personal setup is REALLY raw and
basic. Only lightweight notification via dunst, and dunst can be easy
changed down there...

** org-capture
Org-capture is a nice quick note-taking solution, easily integrable in Deft
essentially we can call a "note" buffer with a pre-defined template AND a
pre-defined "save position" in a specific note file/headline.

#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file "~/.emacs.d/capture/capture.org")
(require 'org-capture)
(global-set-key (kbd "C-M-c") 'org-capture)

(setq org-capture-templates
  (quote (
    ("e" "Emacs TODO / idee / da vedere"  entry
      (file "~/.emacs.d/capture/emacs_captures.org")
        "* %?" :empty-lines 1 :jump-to-captured t
        :unnarrowed t :kill-buffer t)

    ("n" "NixOS TODO / idee / da vedere"  entry
      (file "~/org/note/NixOS_captures.org")
        "* %?" :empty-lines 1 :jump-to-captured t
        :unnarrowed t :kill-buffer t)

    ("a" "AGENDA - eventi e TODOs"  entry
      (file "~/.emacs.d/agenda/agenda.org")
        "* %?" :empty-lines 1 :jump-to-captured t
        :unnarrowed t :kill-buffer t)

    ("t" "TODOs - in agenda"  entry
      (file "~/.emacs.d/agenda/TODOs.org")
        "* %?" :empty-lines 1 :jump-to-captured t
        :unnarrowed t :kill-buffer t))))
#+END_SRC

** org misc setting
A bit of table-related extras
#+BEGIN_SRC emacs-lisp
(use-package orgtbl-aggregate)
(use-package orgtbl-show-header)
(use-package orgtbl-join)
#+END_SRC

A nice helper to build table of contents in org files and
a helper to have nice looking listings in org-export html
#+BEGIN_SRC emacs-lisp
(use-package toc-org)
(use-package htmlize
  :config
    (setq org-html-htmlize-output-type 'inline-css))
#+END_SRC

Finally the big personal settings list.
#+BEGIN_SRC emacs-lisp
(setq
  org-catch-invisible-edits t ; avoid paste in folded contents
  org-support-shift-select t  ; support traditional select via shift+arrows
  org-src-fontify-natively t  ; use proper hilighting in src blocks
  org-src-tab-acts-natively t ; let tab act properly in src block
  org-hide-emphasis-markers t ; hide /.../ *...* =...= markers
  org-cycle-separator-lines 2
  org-pretty-entities t
  org-replace-disputed-keys t
  org-src-preserve-indentation t
  org-blank-before-new-entry '((heading)
                                   (plain-list-item . auto))
  org-ellipsis "⤵" ; instead of ... to indicate folded content
  org-special-ctrl-a/e t ; support jump-to-{beg,end} for folded contents
  org-special-ctrl-k t   ; support kill folded content
  org-yank-adjusted-subtrees t ; properly support yank/kill
  org-edit-src-content-indentation 0 ; do not extra-indent code blocks
) ;; setq

(global-set-key (kbd "s-l") 'org-store-link)
(use-package org-cliplink
  :bind (("s-S-l" . org-cliplink)))

;; yasnippet support fix
(add-hook 'org-mode-hook
          (lambda ()
           (setq-local yas/trigger-key [tab])
           (define-key yas/keymap [tab] 'yas/next-field-or-maybe-expand)))

(defun yas/org-very-safe-expand ()
          (let ((yas/fallback-behavior 'return-nil)) (yas/expand)))

(add-hook 'org-mode-hook
  (lambda ()
    (make-variable-buffer-local 'yas/trigger-key)
    (setq yas/trigger-key [tab])
    (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
    (define-key yas/keymap [tab] 'yas/next-field)))

(font-lock-add-keywords 'org-mode
  '(("^ +\\([-*]\\) "
      (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))

;; supported language for code-embed/listings (syntax hilighting and
;; excute support)
(use-package ob-browser)
(use-package ob-diagrams)
(use-package ob-go)
(use-package ob-rust)
(use-package ob-http)
(use-package ob-async)
(use-package ob-hy)

(org-babel-do-load-languages
  (quote org-babel-load-languages)
    (quote ((emacs-lisp . t)
            (scheme . t)
            (go . t)
	    (shell . t)
	    (ledger . t)
	    (plantuml . t)
	    (latex . t)
	    (ditaa . t)
	    (makefile . t)
	    (python . t)
	    (haskell . t)
	    (lua . t)
	    (dot . t)
	    (C . t)
            (gnuplot . t)
            (perl . t)
	    (sql . t)
	    (hy . t)
	    (calc . t))))
(add-to-list 'org-src-lang-modes '("conf" . conf))

;; Complete LaTeX symbols in org-mode major-mode<Paste>
(defun my-latex-mode-setup ()
  (local-set-key (kbd "C-TAB") 'company-math-symbols-latex))
(add-hook 'org-mode-hook 'my-latex-mode-setup)

;; Complete #+ of org-mode
(defun my-org-mode-hook ()
(add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
(add-hook 'org-mode-hook #'my-org-mode-hook)

;; quick templates for source code blocks
(add-to-list 'org-structure-template-alist
        '("el" "#+BEGIN_SRC emacs-lisp\n\n#+END_SRC" "<src lang=\"emacs-lisp\">\n\n</sr
c>"))

(add-to-list 'org-structure-template-alist
        '("sh" "#+BEGIN_SRC sh :results output \n\n#+END_SRC" "<src lang=\"sh\">\n\n</s
rc>"))
#+END_SRC

A small nice fontify mod by Matus Goljer (Fuco1) from [[https://fuco1.github.io/2017-05
-25-Fontify-done-checkbox-items-in-org-mode.html][this blog post]]
to properly depict checked checkboxes.
#+BEGIN_SRC emacs-lisp :tangle no
(font-lock-add-keywords
 'org-mode
 `(("^[ \t]*\\(?:[-+*]\\|[0-9]+[).]\\)[ \t]+\\(\\(?:\\[@\\(?:start:\\)?[0-9]+\\][ \t]*\
\)?\\[\\(?:X\\|\\([0-9]+\\)/\\2\\)\\][^\n]*\n\\)" 1 'org-headline-done prepend))
 'append)
#+END_SRC

A small bit of lisp inspired by [[http://pragmaticemacs.com/emacs/a-workflow-to-quickly
-add-photos-to-org-mode-notes/][quickly add photos in org-mode]] by Pragmatic
Emacs to easy insert images and display it inline in org-mode buffers
#+BEGIN_SRC emacs-lisp
(setq org-image-actual-width nil)
(defun inline-image ()
 "insert/convert as link a path adding width attribute and toogle
  org-display-inline-images"
 ;; get selected text (path to image)
 (interactive)
 (if mark-active
    (let
       ( (selection (delete-and-extract-region
          (region-beginning) (region-end))) )

       (if (= (length selection) 0)
          (message "empty string")
          (message selection))
       ;; make it a link
       (insert "#+ATTR_ORG: :width 600\n")
       (insert (org-make-link-string (format "file:%s" selection)))
       (org-display-inline-images t t) )
      (error "mark not active")))
#+END_SRC

** Org mode to LaTeX
This part should be re-worked hard!
#+BEGIN_SRC emacs-lisp
(require 'ox-latex)
(setq org-export-latex-listings t)

;; honor space after period in LaTeX export
(setq org-entities-user '(("space" "\\ " nil " " " " " " " ")))

(with-eval-after-load 'ox-latex
(add-to-list 'org-latex-classes
               '("articolo"
                 "\\documentclass{article}

\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{varioref}
\\usepackage{graphicx}
\\usepackage{longtable}
\\usepackage{float}
\\usepackage{wrapfig}
\\usepackage{rotating}
\\usepackage[normalem]{ulem}
\\usepackage{amsmath}
\\usepackage{textcomp}
\\usepackage{marvosym}
\\usepackage{wasysym}
\\usepackage{amssymb}
\\usepackage{hyperref}
\\usepackage[dvipsnames]{xcolor}
\\usepackage[all]{hypcap}
\\usepackage{enumerate}
\\usepackage{fixltx2e}%% \textsubscript and bugfixes for LaTeX
\\usepackage{microtype}

\\pdfcompresslevel=9
\\pdfadjustspacing=1

\\setlength{\\parindent}{0pt}
\\setlength{\\parskip}{\\medskipamount}
[NO-DEFAULT-PACKAGES]
[NO-PACKAGES]
[EXTRA]"
("\\section{%s}" . "\\section*{%s}")
("\\subsection{%s}" . "\\subsection*{%s}")
("\\subsubsection{%s}" . "\\subsubsection*{%s}")
("\\paragraph{%s}" . "\\paragraph*{%s}")
("\\subparagraph{%s}" . "\\subparagraph*{%s}")
("\\subsubparagraph{%s}" . "\\subsubparagraph*{%s}"))))

(setq org-latex-hyperref-template
'"\\hypersetup{
      pdfauthor={%a},
      pdftitle={%t},
      pdfsubject={%d},
      pdfcreator={%c},
      pdfproducer={ox-latex on NixOS},
      pdflang={%l},
      pdfkeywords={%k},
      extension=pdf,
      linkbordercolor=1 1 1,
      menubordercolor=1 1 1,
      urlbordercolor=1 1 1,
      citebordercolor=1 1 1,
      filebordercolor=1 1 1,
      pagebordercolor=1 1 1,
      naturalnames=true,
      plainpages=false,
      final=true,
      pdffitwindow=true,pdfpagelayout=OneColumn,
      linktocpage=false,
      pdfstartview=FitV,
      bookmarksopen=true,
      bookmarksopenlevel=2,
      bookmarksnumbered=false,
      urlcolor=blue,
      colorlinks=true,
      linkcolor=blue,
}\n\n")

(require 'ox-beamer)
(add-to-list 'org-latex-classes
             '("beamer"
	       "\\documentclass\[presentation\]\{beamer\}
\\usepackage[utf8]{inputenc}
\\usepackage[T1]{fontenc}
\\usepackage{longtable}
\\usepackage{wrapfig}
\\usepackage{amsmath}
\\usepackage{textcomp}
\\usepackage{marvosym}
\\usepackage{wasysym}
\\usepackage{amssymb}
\\usepackage{hyperref}
\\usepackage{graphicx}
\\usepackage{rotating}
\\usepackage{capt-of}
\\usepackage{minted}
\\usepackage{enumerate}
\\usepackage{fixltx2e}
\\usepackage{microtype}
\\usepackage{grffile}
\\usepackage[normalem]{ulem}
[NO-DEFAULT-PACKAGES]
[EXTRA]
\\pdfcompresslevel=9
\\pdfadjustspacing=1"
("\\section\{%s\}" . "\\section*\{%s\}")
("\\subsection\{%s\}" . "\\subsection*\{%s\}")
("\\subsubsection\{%s\}" . "\\subsubsection*\{%s\}")))
#+END_SRC

** org-mode presentations
I mainly use three kind of presentations:
 - directly in-org, inside Emacs
 - as pdf via Beamer (LaTeX)
 - as webpages via Reveal.js
#+BEGIN_SRC emacs-lisp
;;(require 'org-show) ;; full-fetured slides in org, in mylisp
(use-package zpresent) ;; quick slides

;; nav. in slide with arrow, n/p or f/b or k/l, 1 or t for top level
;; c/C nav. code blocks, e to edit them, x to run s/S to toggle visibility
;; q to quit.
(use-package epresent) ;; other quick slide pkg

;; Reveal.js slides
;; demand Reveal.js lib locally for offline presentations
;; you need to download latest reveal release from
;; https://github.com/hakimel/reveal.js/releases
;; extract and enter dir and run npm install to install
;; all deps...
;; #+REVEAL_ROOT: file:///home/kim/.emacs.d/reveal.js/
;;Or using the Reveal.js CDN for on-line ones
;; #+REVEAL_ROOT: https://cdn.jsdelivr.net/reveal.js/3.0.0/
(use-package ox-reveal
  :config
    (setq org-reveal-mathjax t
          org-reveal-root "https://cdn.jsdelivr.net/reveal.js/3.0.0/"
          org-reveal-mathjax-url "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"))
#+END_SRC

** org-mode html export settings
#+BEGIN_SRC emacs-lisp
(setq org-html-doctype "html5")
#+END_SRC

* Pdf-tools
is The best pdf viewer I ever found for Emacs, it need some
dependencies (it prompt for su/sudo pass during setup). It must be
manually set-up after elpa install running '~(pdf-tools-install)~' witch
build the neeeded binaries (it must be run also after a pkg update)...

#+BEGIN_SRC emacs-lisp
(use-package pdf-view
  :ensure f
  :bind (:map pdf-view-mode-map
        ("C-s" . isearch-forward))
  :custom (pdf-view-use-unicode-ligther nil))

(use-package pdf-tools
  :init
    ;; inverted colors
  (setq pdf-view-midnight-colors `(,(face-attribute 'default :foreground) .
                                  ,(face-attribute 'default :background)))
  (add-to-list 'auto-mode-alist '("\\.pdf\\'" . pdf-view-mode))

  ;; cua-mode inhibit copy text from pdfs...
  (require 'pdf-view)
  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
  (add-hook 'pdf-view-mode-hook (lambda () (pdf-tools-enable-minor-modes 1)))

  (setq pdf-view-resize-factor 1.1)
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward))
#+END_SRC

* epub native support
#+BEGIN_SRC emacs-lisp
(use-package nov
  :init
    (add-to-list 'auto-mode-alist '("\\.epub\\'" . nov-mode))
    (setq nov-text-width 80))
#+END_SRC

* Python support
Well, I'm NOT a developer, I use python only for small potatoes stuff
so my config here is really small. Keep in mind that jedi need a server
to work with. Since I start using it on NixOS I simply install jedi
via NixOS emacsPackagesNg, I do not try on Ubuntu&c...

If you look for more stuff try also
 - [[https://github.com/proofit404/anaconda-mode][Anaconda mode]] a wrapper around Jedi
 with virtualenv/docker support
 - [[https://github.com/jorgenschaefer/elpy/wiki][ELPY]] a "pyhton IDE" for Emacs

#+BEGIN_SRC emacs-lisp
(use-package jedi
  :init (add-to-list 'company-backends 'company-jedi)
  :config
    (add-hook 'python-mode-hook 'jedi:setup)
    (setq jedi:complete-on-dot t)

    ;; force python3 interpeter
    (setq jedi:environment-root "jedi")
    (setq jedi:environment-virtualenv
      (append python-environment-virtualenv
        '("--python" "/run/current-system/sw/bin/python3"))))

(use-package company-jedi
  :init
    (add-hook 'python-mode-hook (lambda ()
      (add-to-list 'company-backends 'company-jedi)))
    (setq company-jedi-python-bin "python3"))
#+END_SRC

* Lisp(s) support
Very few lisp-only related stuff...
#+BEGIN_SRC emacs-lisp
(use-package paredit)
(use-package parinfer
  :init
    (progn
      (setq parinfer-extensions
        '(defaults       ; should be included.
	  pretty-parens  ; different paren styles for different modes.
	  paredit        ; Introduce some paredit commands.<Paste>
          smart-tab      ; C-b/C-f jump positions and shift with tab/S-tab.
          smart-yank))   ; Yank behavior depend on mode.

      (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
      (add-hook 'common-lisp-mode-hook #'parinfer-mode)
      (add-hook 'scheme-mode-hook #'parinfer-mode)
      (add-hook 'lisp-mode-hook #'parinfer-mode)))
#+END_SRC

A nice lisp is Hy (hylang), whitch is... Well Python with lisp-y syntax..
#+BEGIN_SRC emacs-lisp
(use-package hy-mode)
#+END_SRC

* Scheme support
#+BEGIN_SRC emacs-lisp
(use-package geiser
  :config
    (setq geiser-default-implementation (executable-find "guile") )
    (setq geiser-active-implementation (executable-find "guile") )
    (setq geiser-guile-load-init-file-p t)
    (setq-default geiser-mode-auto-p nil)

    (add-hook 'geiser-mode-hook (lambda ()
      (setq geiser-impl--implementation (executable-find "guile")))))
#+END_SRC

* eshell && font awesome
#+BEGIN_SRC emacs-lisp
(use-package sane-term)
(use-package pcmpl-args)
(use-package pcmpl-pip)
(use-package google-translate)
(use-package fish-completion)
(use-package fontawesome)

;; avoid prompt delection
(setq comint-prompt-read-only t)

(require 'eshell)
(require 'em-smart)
(require 'dash)
(require 's)

(defmacro with-face (STR &rest PROPS)
  "Return STR propertized with PROPS."
    `(propertize ,STR 'face (list ,@PROPS)))

(defmacro esh-section (NAME ICON FORM &rest PROPS)
  "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
    `(setq ,NAME
             (lambda () (when ,FORM
	                      (-> ,ICON
			                          (concat esh-section-delim ,FORM)
						                      (with-face ,@PROPS))))))

(defun esh-acc (acc x)
  "Accumulator for evaluating and concatenating esh-sections."
    (--if-let (funcall x)
          (if (s-blank? acc)
	            it
		            (concat acc esh-sep it))
			        acc))


(defun esh-prompt-func ()
  "Build `eshell-prompt-function'"
    (concat esh-header
              (-reduce-from 'esh-acc "" eshell-funcs)
	                "\n"
			          eshell-prompt-string))

(esh-section esh-dir
             "\xf07c"  ;  (faicon folder)
	                  (abbreviate-file-name (eshell/pwd))
			               '(:foreground "gold" :underline t))


(esh-section esh-clock
             "\xf017"  ;  (clock icon)
	                  (format-time-string "%H:%M" (current-time))
			               '(:foreground "forest green"))

;; Below I implement a "prompt number" section
(setq esh-prompt-num 0)
(add-hook 'eshell-exit-hook (lambda () (setq esh-prompt-num 0)))
(advice-add 'eshell-send-input :before
            (lambda (&rest args) (setq esh-prompt-num (incf esh-prompt-num))))

(esh-section esh-num
             "\xf0c9"  ;  (list icon)
	                  (number-to-string esh-prompt-num)
			               '(:foreground "brown"))

;; Separator between esh-sections
(setq esh-sep "  ")  ; or " | "

;; Separator between an esh-section icon and form
(setq esh-section-delim " ")

;; Eshell prompt header
(setq esh-header "\n┌─")  ; or "\n┌─"

;; Eshell prompt regexp and string. Unless you are varying the prompt by eg.
;; your login, these can be the same.
(setq eshell-prompt-regexp "└─> ")   ; or "└─> "
(setq eshell-prompt-string "└─> ")   ; or "└─> "

;; Choose which eshell-funcs to enable
(setq eshell-funcs (list esh-dir esh-clock esh-num))

;; Enable the new eshell prompt
(setq eshell-prompt-function 'esh-prompt-func)

(require 'fish-completion)
(when (and (executable-find "fish")
           (require 'fish-completion nil t))
	     (global-fish-completion-mode))

(with-eval-after-load 'em-term
  (dolist (p '("abook" "alsamixer" "cmus" "fzf" "gtypist"
                 "htop" "mpsyt" "mpv" "mutt" "ncdu" "iftop"
		                "mplayer" "ranger" "watch" "ssh" "tail" "top" "htop"))
				(add-to-list 'eshell-visual-commands p))
				(setq eshell-visual-subcommands
				        '( ("sudo" "vi" "visudo" "git" "log" "l" "diff" "show" ) )))

(add-hook 'shell-mode-hook #'company-mode)
(define-key shell-mode-map (kbd "TAB") #'company-manual-begin)

(setq eshell-scroll-to-bottom-on-input 'all
      eshell-error-if-no-glob t
            eshell-hist-ignoredups t
	          eshell-save-history-on-exit t
		        eshell-prefer-lisp-functions nil
			      eshell-cmpl-cycle-completions nil
			            eshell-destroy-buffer-when-process-dies t)

(add-hook 'eshell-mode-hook (lambda ()
 (eshell/alias "killX" "sudo pkill X")
 (eshell/alias "e" "find-file $1")
  (eshell/alias "sysclean" "sudo nix-collect-garbage -d ; sudo nix-store --gc; sudo nix-
  store  --optimize")
 (eshell/alias "sysup" "sudo nixos-rebuild switch --upgrade && nix-env -u")
 (eshell/alias "sysbe" "sudo nix-env -p /nix/var/nix/profiles/system --list-generations
 ")
  (eshell/alias "sysDelBE" "sudo nix-env -p /nix/var/nix/profiles/system --delete-genera
  tions")
   (eshell/alias "ee" "find-file-other-window $1")
    (eshell/alias "l" "ls $*")
     (eshell/alias "ll" "ls -lh $*")
 (eshell/alias "d" "dired $PWD")
))

(defun eclear ()
  (interactive)
    (when (eq major-mode 'eshell-mode)
        (goto-char (point-max))
	    (let ((inhibit-read-only t))
	          (delete-region (point-min) (point-at-bol)) )))


;; use counsel for searching eshell history
(add-hook 'eshell-mode-hook
  (lambda ()
      (define-key eshell-mode-map (kbd "M-h")
            (lambda () (interactive) (counsel-esh-history)))))
#+END_SRC

* web-mode / emmet-mode
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :mode (".html?" ".css$")
  :init
    (setq web-mode-markup-indent-offset 2
          web-mode-css-indent-offset 2
	  web-mode-code-indent-offset 2
	  web-mode-enable-auto-closing t
	  web-mode-enable-auto-opening t
	  web-mode-enable-auto-pairing t
	  web-mode-enable-auto-indentation t)

    ;; stealed from Kiran Gangadharan (kirang89) emacs config
    (defun surround-html (start end tag)
    "Wraps the specified region (or the current 'symbol / word'
     with a properly formatted HTML tag."
     (interactive "r\nsTag: " start end tag)
     (save-excursion
       (narrow-to-region start end)
       (goto-char (point-min))
       (insert (format "<%s>" tag))
       (goto-char (point-max))
       (insert (format "</%s>" tag))
       (widen))))

(use-package emmet-mode
  :diminish (emmet-mode . "ε")
  :init
    (setq emmet-indentation 2)
    (setq emmet-move-cursor-between-quotes t)
  :config
    (add-hook 'web-mode-hook 'emmet-mode)
    (add-hook 'css-mode-hook  'emmet-mode))
#+END_SRC

* plantuml-mode
It's a nice language to design diagrams in pure text. Syntax it
really simple and produced diagrams looking pretty enough. The
syntax [[http://plantuml.com/PlantUML_Language_Reference_Guide.pdf][reference]] (pdf) i
s a bit big but basic usage is terribly
simple.

#+BEGIN_EXAMPLE
(*) --> "Diagram entry point and this description"

--> "Linked to previous one"

if "We start yes/no choice" then
  -->[yes] "yes choice" as yc
else
  ->[no] if "no choice" then
    -->[yes] yc
  else
    ->[no] "Another else" as el
  endif
endif

yc --> "new subdiagram start from yc above"
#+END_EXAMPLE

#+BEGIN_SRC emacs-lisp
(use-package graphviz-dot-mode
  :config
    (setq graphviz-dot-dot-program "/run/current-system/sw/bin/dot"))

(use-package plantuml-mode
  :config
    (setq org-plantuml-jar-path
      (expand-file-name "~/.emacs.d/plantuml/plantuml.jar")))

(use-package flycheck-plantuml)
#+END_SRC

* erc - Emacs IRC client
Is a nice and featured client, however I do not really use IRC, I put
it here just for reference and potential occasional use...
#+BEGIN_SRC emacs-lisp  :tangle no
(setq erc-nick "xte")
(setq erc-server  "irc.freenode.net")
(setq erc-port    6667)

(defun connect-to-freenode ()
  (interactive)
    (erc :server freenode-server))

(defun erc-kill-all-buffers ()
  (interactive)
    (erc-cmd-GQUIT "disconnected, BRB")
      (let ((erc-buffers (erc-buffer-list)))
          (dolist (b erc-buffers)
	        (kill-buffer b) )))

(add-hook 'erc-mode-hook #'erc-scrolltobottom-enable)

(use-package erc-hl-nicks :config (erc-update-modules))

(use-package erc-image
  :config
    (add-to-list 'erc-modules 'image)
    (setq erc-image-inline-rescale 512)
    (erc-update-modules))
#+END_SRC

* Zotero - zotxt integration
Yes, I decide to go for Zotero, even if it's a non-emacs, web-centric
application that essentially run in Firefox (so only a bit less ugly
than Electron app) simply because it works out-of-the-box instead of
a long thedious process with org-capture and org-protocol extension
to capture and attach resourses... Probably in the future I'll go
for org-ref and abandon Zotero, but for now...

to insert a reference call/bound to something
  ~org-zotxt-insert-reference-link~

Remember Zotero need zotxt extension (manually downloaded from it SCM
release page) to work. And it also suggest BetterBibTeX extension to
properly integrate citation with LaTeX.

#+BEGIN_SRC emacs-lisp
(use-package zotxt
 :init
  (add-hook 'org-mode-hook (lambda () (org-zotxt-mode 1))))
#+END_SRC

* final touch
#+BEGIN_SRC emacs-lisp

;; Local Variables:
;; byte-compile-warnings: (not free-vars callargs unresolved)
;; End:
#+END_SRC
