#+AUTHOR: Sylvain Ribstein
#+TITLE: GNU Emacs Configuration

* Emacs Initialization
** Packages Sources
   In order to install packages, it is useful to configure the package sources.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq package-archives '(
     ("melpa" . "http://melpa.org/packages/")
     ("gnu" . "http://elpa.gnu.org/packages/")
     ("org" . "http://orgmode.org/elpa/")
     ("marmalade" . "http://marmalade-repo.org/packages/")
     ))
#+END_SRC
** use-package
   To be able to manage its configuration with =use-package= it is necessary to
   first install it, if you don't already.
   *NOTE:* Need to understand if it use also the package manager of emacs
   Also ensure that the package is installed and if not tries to install it.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (use-package use-package-ensure-system-package :ensure t)
#+END_SRC

** delight
   delight is a way of showing wich major/minor is currently open
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package delight :ensure t)
#+END_SRC

* Start Up
** Authentification
   In which file the authentification is save
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq auth-sources '("~/.gnupg/shared/authinfo.gpg"
                       "~/.authinfo.gpg"
;;                       "~/.authinfo"
;;                       "~/.netrc"
  ))
#+END_SRC

** Better defaults
For a better user experience of GNU Emacs, here are the default values I use.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
  ad-redefinition-action 'accept                   ; Silence warnings for redefinition
  cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
  display-time-default-load-average nil            ; Don't display load average
  fill-column 80                                   ; Set width for automatic line breaks
  help-window-select t                             ; Focus new help windows when opened
  inhibit-startup-screen t                         ; Disable start-up screen
  initial-scratch-message ""                       ; Empty the initial *scratch* buffer
  kill-ring-max 128                                ; Maximum length of kill ring
  load-prefer-newer t                              ; Prefers the newest version of a file
  mark-ring-max 128                                ; Maximum length of mark ring
  scroll-conservatively most-positive-fixnum       ; Always scroll by one line
  select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
  tab-width 4                                      ; Set width for tabs
  use-package-always-ensure t                      ; Avoid the :ensure keyword for each package
  user-full-name "Sylvain Ribstein"                ; Set the full name of the current user
  user-mail-address "sylvain.ribstein@gmail.com"   ; Set the email address of the current user
  vc-follow-symlinks t                             ; Always follow the symlinks
  view-read-only t)                                ; Always open read-only buffers in view-mode
 (cd "~/")                                        ; Move to the user directory
 (column-number-mode 1)                           ; Show the column number
 (display-time-mode 1)                            ; Enable time in the mode-line
 (fset 'yes-or-no-p 'y-or-n-p)                    ; Replace yes/no prompts with y/n
 (global-hl-line-mode)                            ; Hightlight current line
 (set-default-coding-systems 'utf-8)              ; Default to utf-8 encoding
 (show-paren-mode 1)                              ; Show the parenthesis
#+END_SRC

** XDG :notused:

*NOTE:* I'm not using that config yet. Need to understand why doing it in emacs

# To keep the user's home and the =~/.emacs.d= folder as clean as possible, I
# follow the [[https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html][XDG base directory specification]].

# Be careful that GNU Emacs will not create the appropriate folders if they do not
# exist. Therefore, it is necessary to create them yourself:

# #+BEGIN_SRC bash
#   mkdir ~/.cache/emacs ~/.local/share/emacs/
# #+END_SRC

*NOTE:* you can find out more by going to my [[https://github.com/rememberYou/dotfiles][dotfiles]].

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (defvar xdg-bin (getenv "XDG_BIN_HOME")
#   "The XDG bin base directory.")

#   (defvar xdg-cache (getenv "XDG_CACHE_HOME")
#     "The XDG cache base directory.")

#   (defvar xdg-config (getenv "XDG_CONFIG_HOME")
#     "The XDG config base directory.")

#   (defvar xdg-data (getenv "XDG_DATA_HOME")
#     "The XDG data base directory.")

#   (defvar xdg-lib (getenv "XDG_LIB_HOME")
#     "The XDG lib base directory.")
# #+END_SRC

** Customization

To avoid overloading the GNU Emacs custormization =init.el= file made by the
user with the UI, I add the generated code in a separate file.


#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default custom-file (expand-file-name "~/.emacs.d/custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file t))
#+END_SRC

** Theme :notused:
   *NOTE:* I prefer to use the default .Xressources file
   I like the light on dark because I find it to be more restful.

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package nord-theme
 #    :config
# (add-to-list 'custom-theme-load-path (expand-file-name "~/.emacs.d/themes/"))
#      (load-theme 'nord t))
#    (use-package smart-mode-line
#     :defer 0.1
#     :custom (sml/theme 'respectful)
#     :config (sml/setup))
 #+END_SRC

** Turn off mouse interface
Since I never use the mouse with GNU Emacs, I prefer not to use certain
graphical elements as seen as the menu bar, toolbar, scrollbar and tooltip that
I find invasive.

#+BEGIN_SRC emacs-lisp :tangle yes
  (when window-system
    (menu-bar-mode -1)                              ; Disable the menu bar
    (scroll-bar-mode -1)                            ; Disable the scroll bar
    (tool-bar-mode -1)                              ; Disable the tool bar
    (tooltip-mode -1))                              ; Disable the tooltips
#+END_SRC

* Advanced Configuration
** Alert :notused:

# Most packages use =alerts= to make notifications with =libnotify=. Don't forget
# to first install a notification daemon, like =dunst=.

# #+BEGIN_QUOTE
# Alert is a Growl-workalike for Emacs which uses a common notification interface
# and multiple, selectable "styles", whose use is fully customizable by the user.

# [[https://github.com/jwiegley/alert][John Wiegley]]
# #+END_QUOTE

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package alert
#     :custom (alert-default-style 'libnotify))
# #+END_SRC

** Auto-Completion (company)

=company= provides auto-completion at point and to Displays a small pop-in
containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :defer 0.5
    :delight
    :custom
    (company-begin-commands '(self-insert-command))
    (company-idle-delay .1)
    (company-minimum-prefix-length 2)
    (company-show-numbers t)
    (company-tooltip-align-annotations 't)
    (global-company-mode t))
#+END_SRC

# I use =company= with =company-box= that allows a company front-end with icons.

# #+BEGIN_SRC emacs-lisp :tangle yes
#    (use-package company-box
#      :after company
#      :delight
#      :hook (company-mode . company-box-mode))
# #+END_SRC

** Backups

It is important to have a stable backup environment. Don't hesitate to save a
lot.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package files
    :ensure nil
    :custom
    (backup-directory-alist `(("." . "~/.emacs.d/backup")))
    (delete-old-versions -1)
    (vc-make-backup-files t)
    (version-control t))
#+END_SRC

** Browser (Firefox)
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-firefox)
#+END_SRC

*** =engine-mode=
	With it I can start a search from within emacs.
	I use duckduckgo and bang

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package engine-mode
    :defer 3
    :config
    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d"))
#+END_SRC

** Buffers

#+BEGIN_SRC emacs-lisp :tangle yes
(use-package ace-window
  :bind ("M-o" . ace-window)
  :init (setq aw-keys '(?q ?s ?d ?f ?g ?h ?j ?k ?l)))
  (use-package ibuffer
    :defer 0.2
    :bind ("C-x C-b" . ibuffer))
;;  (use-package ibuffer-projectile
;;   :after ibuffer
;;   :preface
;;   (defun my/ibuffer-projectile ()
;;     (ibuffer-projectile-set-filter-groups)
;;    (unless (eq ibuffer-sorting-mode 'alphabetic)
;;        (ibuffer-do-sort-by-alphabetic)))
;;    :hook (ibuffer . my/ibuffer-projectile))
#+END_SRC
** Calculator :notused:

# # May be useful in a timely manner.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package calc
# #     :defer t
# #     :custom
# #     (math-additional-units
# #      '((GiB "1024 * MiB" "Giga Byte")
# #        (MiB "1024 * KiB" "Mega Byte")
# #        (KiB "1024 * B" "Kilo Byte")
# #        (B nil "Byte")
# #        (Gib "1024 * Mib" "Giga Bit")
# #        (Mib "1024 * Kib" "Mega Bit")
# #        (Kib "1024 * b" "Kilo Bit")
# #        (b "B / 8" "Bit")))
# #     (math-units-table nil))
# # #+END_SRC

** Calendar :notused:

# # Remembering all the dates is not obvious, especially since some varies every
# # year. In order to remember each important date, I recorded the list of important
# # dates according to my country, Belgium. It is very likely that some dates are
# # different in your country, therefore, adapt the configuration below accordingly.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package calendar
# #     :custom (calendar-mark-holidays-flag t))

# #   (use-package holidays
# #     :ensure nil
# #     :custom
# #     (holiday-bahai-holidays nil)
# #     (holiday-christian-holidays
# #      '((holiday-fixed 1 6 "Epiphany")
# #        (holiday-fixed 2 2 "Candlemas")
# #        (holiday-easter-etc -47 "Mardi Gras")
# #        (holiday-easter-etc 0 "Easter Day")
# #        (holiday-easter-etc 1 "Easter Monday")
# #        (holiday-easter-etc 39 "Ascension")
# #        (holiday-easter-etc 49 "Pentecost")
# #        (holiday-fixed 8 15 "Assumption")
# #        (holiday-fixed 11 1 "All Saints' Day")
# #        (holiday-fixed 11 2 "Day of the Dead")
# #        (holiday-fixed 11 22 "Saint Cecilia's Day")
# #        (holiday-fixed 12 1 "Saint Eloi's Day")
# #        (holiday-fixed 12 4 "Saint Barbara")
# #        (holiday-fixed 12 6 "Saint Nicholas Day")
# #        (holiday-fixed 12 25 "Christmas Day")))
# #     (holiday-general-holidays
# #      '((holiday-fixed 1 1 "New Year's Day")
# #        (holiday-fixed 2 14 "Valentine's Day")
# #        (holiday-fixed 3 8 "International Women's Day")
# #        (holiday-fixed 10 31 "Halloween")
# #        (holiday-fixed 11 11 "Armistice of 1918")))
# #     (holiday-hebrew-holidays nil)
# #     (holiday-islamic-holidays nil)
# #     (holiday-local-holidays
# #      '((holiday-fixed 5 1 "Labor Day")
# #        (holiday-float 3 0 0 "Grandmothers' Day")
# #        (holiday-float 4 4 3 "Secretary's Day")
# #        (holiday-float 5 0 2 "Mother's Day")
# #        (holiday-float 6 0 3 "Father's Day")))
# #     (holiday-oriental-holidays nil))
# # #+END_SRC

** Dashboard
Always good to have a dashboard.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dashboard
    :preface
    :init
    (add-hook 'after-init-hook 'dashboard-refresh-buffer)
    (add-hook 'dashboard-mode-hook 'my/dashboard-banner)
    :custom (dashboard-startup-banner 'logo)
    :config (dashboard-setup-startup-hook))
#+END_SRC
** Ending Up :notused:


not-sur to understand how it works
I'm using an =.org= file to maintain my GNU Emacs configuration. However, at his
launch, it will loads the =config.el= source file for a faster loading.

The code below, executes =org-babel-tangle= asynchronously when
=config.org= is saved.

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package async)

#   (defvar *config-file* (expand-file-name "config.org" user-emacs-directory)
#     "The configuration file.")

#   (defvar *config-last-change* (nth 5 (file-attributes *config-file*))
#     "Last modification time of the configuration file.")

#   (defvar *show-async-tangle-results* nil
#     "Keeps *emacs* async buffers around for later inspection.")

#   (defun my/config-updated ()
#     "Checks if the configuration file has been updated since the last time."
#     (time-less-p *config-last-change*
#                  (nth 5 (file-attributes *config-file*))))

#   (defun my/config-tangle ()
#     "Tangles the org file asynchronously."
#     (when (my/config-updated)
#       (setq *config-last-change*
#             (nth 5 (file-attributes *config-file*)))
#       (my/async-babel-tangle *config-file*)))

#   (defun my/async-babel-tangle (org-file)
#     "Tangles the org file asynchronously."
#     (let ((init-tangle-start-time (current-time))
#           (file (buffer-file-name))
#           (async-quiet-switch "-q"))
#       (async-start
#        `(lambda ()
#           (require 'org)
#           (org-babel-tangle-file ,org-file))
#        (unless *show-async-tangle-results*
#          `(lambda (result)
#             (if result
#                 (message "SUCCESS: %s successfully tangled (%.2fs)."
#                          ,org-file
#                          (float-time (time-subtract (current-time)
#                                                     ',init-tangle-start-time)))
#               (message "ERROR: %s as tangle failed." ,org-file)))))))
# #+END_SRC

** Spelling
*** Abbreviations

According to a list of misspelled words, =abbrev= auto-correct these words on
the fly.
*NOTE:* Should add my file
a way to generate it ?
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package abbrev
    :defer 1
    :ensure nil
    :delight
    :hook (text-mode . abbrev-mode)
    :custom (abbrev-file-name "~/.emacs.d/abbrev_defs")
    :config
    (if (file-exists-p abbrev-file-name)
        (quietly-read-abbrev-file)))
#+END_SRC

*** Fly Spell

For the other words that would not be in my list of abbreviations, =flyspell=
enables spell checking on-the-fly in GNU Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package flyspell
    :defer 1
    :delight
    :custom
    (flyspell-abbrev-p t)
    (flyspell-issue-message-flag nil)
    (flyspell-issue-welcome-flag nil)
    (flyspell-mode 1))

  (use-package flyspell-correct-ivy
    :after flyspell
    :bind (:map flyspell-mode-map
                ("C-;" . flyspell-correct-word-generic))
    :custom (flyspell-correct-interface 'flyspell-correct-ivy))

  (use-package ispell
    :custom
    (ispell-silently-savep t))
#+END_SRC

*** Grammar Checker :notused:
*NOTE:* Need to install some stuff
[[https://languagetool.org/][LanguageTool]] is great for correcting your grammar. Combined with =abbrev-mode=
and =flyspell=, you will have better documents. In order to be able to use it
locally, download the desktop version and change the paths indicated below.

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package langtool
#     :defer 2
#     :delight
#     :custom
#     (langtool-language-tool-jar "~/.local/lib/LangueageTool-4.2/languagetool-commandline.jar")
#     (langtool-language-tool-server-jar "~/.local/lib/LanguageTool-4.2/languagetool-server.jar"))
# #+END_SRC

** History

Provides the ability to have commands and their history saved so that whenever
you return to work, you can re-run things as you need them. This is not a
radical function, it is part of a good user experience.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package savehist
    :ensure nil
    :custom
    (history-delete-duplicates t)
    (history-length t)
    (savehist-additional-variables
     '(kill-ring
       search-ring
       regexp-search-ring))
    (savehist-file  "~/.emacs.d/history" )
    (savehist-save-minibuffer-history 1)
    :config (savehist-mode 1))
#+END_SRC

** Hydra :notused:

maybe I should start using it

# # Hydra allows me to display a list of all the commands implemented in the echo
# # area and easily interact with them.

# # #+BEGIN_QUOTE
# # Once you summon the Hydra through the prefixed binding (the body + any one
# # head), all heads can be called in succession with only a short extension.

# # The Hydra is vanquished once Hercules, any binding that isn't the Hydra's head,
# # arrives. Note that Hercules, besides vanquishing the Hydra, will still serve his
# # original purpose, calling his proper command. This makes the Hydra very
# # seamless, it's like a minor mode that disables itself auto-magically.

# # [[https://github.com/abo-abo/hydra][Oleh Krehel]]
# # #+END_QUOTE

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package hydra
# #     :defer 0.5
# #     :bind (("C-c L" . hydra-ledger/body)
# #            ("C-c P" . hydra-projectile/body)
# #            ("C-c b" . hydra-buffer/body)
# #            ("C-c c" . hydra-clock/body)
# #            ("C-c e" . hydra-erc/body)
# #            ("C-c f" . hydra-flycheck/body)
# #            ("C-c g" . hydra-go-to-file/body)
# #            ("C-c m" . hydra-magit/body)
# #            ("C-c o" . hydra-org/body)
# #            ("C-c s" . hydra-spelling/body)
# #            ("C-c p t" . hydra-typescript/body)
# #            ("C-c y" . hydra-yasnippet/body)
# #            ("C-c w" . hydra-windows/body)))
# # #+END_SRC

*** Hydra / Buffer

# # Group Buffer commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-buffer (:color blue)
# #     "
# #     ^
# #     ^Buffer^             ^Do^
# #     ^──────^─────────────^──^──────────
# #     _q_ quit             _k_ kill
# #     ^^                   _l_ list
# #     ^^                   _n_ next
# #     ^^                   _p_ previous
# #     ^^                   ^^
# #     "
# #     ("q" nil)
# #     ("k" kill-buffer)
# #     ("l" ibuffer)
# #     ("n" next-buffer)
# #     ("p" previous-buffer))
# # #+END_SRC

*** Hydra / Clock

# # Group clock commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-clock (:color blue)
# #     "
# #     ^
# #     ^Clock^             ^Do^
# #     ^─────^─────────────^──^─────────
# #     _q_ quit            _c_ cancel
# #     ^^                  _d_ display
# #     ^^                  _e_ effort
# #     ^^                  _i_ in
# #     ^^                  _j_ jump
# #     ^^                  _o_ out
# #     ^^                  _r_ report
# #     ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("c" org-clock-cancel)
# #     ("d" org-clock-display)
# #     ("e" org-clock-modify-effort-estimate)
# #     ("i" org-clock-in)
# #     ("j" org-clock-goto)
# #     ("o" org-clock-out)
# #     ("r" org-clock-report))
# # #+END_SRC

*** Hydra / ERC

# # Group ERC commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-erc (:color blue)
# #     "
# #     ^
# #     ^ERC^             ^Do^
# #     ^───^─────────────^──^────────────
# #     _q_ quit          _c_ connect
# #     ^^                _d_ disconnect
# #     ^^                _j_ join
# #     ^^                _n_ names
# #     ^^                _u_ users
# #     ^^                ^^
# #     "
# #     ("q" nil)
# #     ("c" my/erc-start-or-switch)
# #     ("d" erc-quit-server)
# #     ("j" erc-join-channel)
# #     ("n" erc-channel-names)
# #     ("u" my/erc-count-users))
# # #+END_SRC

*** Hydra / Flycheck

# # Group Flycheck commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-flycheck (:color blue)
# #     "
# #     ^
# #     ^Flycheck^          ^Errors^            ^Checker^
# #     ^────────^──────────^──────^────────────^───────^─────
# #     _q_ quit            _<_ previous        _?_ describe
# #     _M_ manual          _>_ next            _d_ disable
# #     _v_ verify setup    _f_ check           _m_ mode
# #     ^^                  _l_ list            _s_ select
# #     ^^                  ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("<" flycheck-previous-error :color pink)
# #     (">" flycheck-next-error :color pink)
# #     ("?" flycheck-describe-checker)
# #     ("M" flycheck-manual)
# #     ("d" flycheck-disable-checker)
# #     ("f" flycheck-buffer)
# #     ("l" flycheck-list-errors)
# #     ("m" flycheck-mode)
# #     ("s" flycheck-select-checker)
# #     ("v" flycheck-verify-setup))
# # #+END_SRC

*** Hydra / Go To

# # Group jump-to-files commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-go-to-file (:color blue)
# #     "
# #     ^
# #     ^Go To^           ^Config^            ^Agenda             ^Other^
# #     ^─────^───────────^──────^────────────^──────^────────────^─────^────────
# #     _q_ quit          _ca_ alacritty      _ac_ contacts       _ob_ book
# #     ^^                _cd_ dunst          _af_ findmycat      _ol_ learning
# #     ^^                _ce_ emacs          _ao_ organizer      _om_ movies
# #     ^^                _ci_ i3             _ap_ people         _op_ purchases
# #     ^^                _cn_ neofetch       _ar_ routine        _ou_ usb
# #     ^^                _cp_ polybar        _as_ school         ^^
# #     ^^                _cq_ qutebrowser    ^^                  ^^
# #     ^^                _cR_ rofi           ^^                  ^^
# #     ^^                _cr_ ranger         ^^                  ^^
# #     ^^                _cs_ sway           ^^                  ^^
# #     ^^                _ct_ tmux           ^^                  ^^
# #     ^^                ^^                  ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("ac" (find-file "~/.personal/agenda/contacts.org"))
# #     ("af" (find-file "~/.personal/agenda/findmycat.org"))
# #     ("ao" (find-file "~/.personal/agenda/organizer.org"))
# #     ("ap" (find-file "~/.personal/agenda/people.org"))
# #     ("ar" (find-file "~/.personal/agenda/routine.org"))
# #     ("as" (find-file "~/.personal/agenda/school.org"))
# #     ("ca" (find-file (format "%s/alacritty/alacritty.yml" xdg-config)))
# #     ("cd" (find-file (format "%s/dunst/dunstrc" xdg-config)))
# #     ("ce" (find-file "~/.emacs.d/config.org"))
# #     ("ci" (find-file (format "%s/i3/config" xdg-config)))
# #     ("cn" (find-file (format "%s/neofetch/config.conf" xdg-config)))
# #     ("cp" (find-file (format "%s/polybar/config" xdg-config)))
# #     ("cq" (find-file (format "%s/qutebrowser/config.py" xdg-config)))
# #     ("cR" (find-file (format "%s/rofi/config.rasi" xdg-config)))
# #     ("cr" (find-file (format "%s/ranger/rc.conf" xdg-config)))
# #     ("cs" (find-file (format "%s/sway/config" xdg-config)))
# #     ("ct" (find-file (format "%s/tmux/tmux.conf" xdg-config)))
# #     ("ob" (find-file "~/.personal/other/books.org"))
# #     ("ol" (find-file "~/.personal/other/learning.org"))
# #     ("om" (find-file "~/.personal/other/movies.org"))
# #     ("op" (find-file "~/.personal/other/purchases.org"))
# #     ("ou" (find-file "~/.personal/other/usb.org")))
# # #+END_SRC

*** Hydra / Ledger

# # Group Ledger commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-ledger (:color blue)
# #     "
# #     ^
# #     ^Ledger^             ^Do^
# #     ^──────^─────────────^──^────────
# #     _q_ quit             _a_ add
# #     ^^                   _c_ clear
# #     ^^                   _C_ copy
# #     ^^                   _d_ delete
# #     ^^                   _r_ report
# #     ^^                   ^^
# #     "
# #     ("q" nil)
# #     ("a" ledger-add-transaction)
# #     ("c" ledger-mode-clean-buffer)
# #     ("C" ledger-copy-transaction-at-point)
# #     ("d" ledger-delete-current-transaction)
# #     ("r" ledger-report))
# # #+END_SRC

*** Hydra / Magit

# # Group Magit commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-magit (:color blue)
# #     "
# #     ^
# #     ^Magit^             ^Do^
# #     ^─────^─────────────^──^────────
# #     _q_ quit            _b_ blame
# #     ^^                  _c_ clone
# #     ^^                  _i_ init
# #     ^^                  _s_ status
# #     ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("b" magit-blame)
# #     ("c" magit-clone)
# #     ("i" magit-init)
# #     ("s" magit-status))
# # #+END_SRC

*** Hydra / Org

# # Group Org commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-org (:color blue)
# #     "
# #     ^
# #     ^Org^             ^Do^
# #     ^───^─────────────^──^─────────────
# #     _q_ quit          _A_ archive
# #     ^^                _a_ agenda
# #     ^^                _c_ capture
# #     ^^                _d_ decrypt
# #     ^^                _i_ insert-link
# #     ^^                _j_ jump-task
# #     ^^                _k_ cut-subtree
# #     ^^                _o_ open-link
# #     ^^                _r_ refile
# #     ^^                _s_ store-link
# #     ^^                _t_ todo-tree
# #     ^^                ^^
# #     "
# #     ("q" nil)
# #     ("A" my/org-archive-done-tasks)
# #     ("a" org-agenda)
# #     ("c" org-capture)
# #     ("d" org-decrypt-entry)
# #     ("k" org-cut-subtree)
# #     ("i" org-insert-link-global)
# #     ("j" my/org-jump)
# #     ("o" org-open-at-point-global)
# #     ("r" org-refile)
# #     ("s" org-store-link)
# #     ("t" org-show-todo-tree))
# # #+END_SRC

*** Hydra / Projectile

# # Group Projectile commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-projectile (:color blue)
# #     "
# #     ^
# #     ^Projectile^        ^Buffers^           ^Find^              ^Search^
# #     ^──────────^────────^───────^───────────^────^──────────────^──────^────────────
# #     _q_ quit            _b_ list            _d_ directory       _r_ replace
# #     _i_ reset cache     _K_ kill all        _D_ root            _R_ regexp replace
# #     ^^                  _S_ save all        _f_ file            _s_ search
# #     ^^                  ^^                  _p_ project         ^^
# #     ^^                  ^^                  ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("b" counsel-projectile-switch-to-buffer)
# #     ("d" counsel-projectile-find-dir)
# #     ("D" projectile-dired)
# #     ("f" counsel-projectile-find-file)
# #     ("i" projectile-invalidate-cache :color red)
# #     ("K" projectile-kill-buffers)
# #     ("p" counsel-projectile-switch-project)
# #     ("r" projectile-replace)
# #     ("R" projectile-replace-regexp)
# #     ("s" counsel-projectile-git-grep)
# #     ("S" projectile-save-project-buffers))
# # #+END_SRC

*** Hydra / Spelling

# # Group spelling commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-spelling (:color blue)
# #     "
# #     ^
# #     ^Spelling^          ^Errors^            ^Checker^
# #     ^────────^──────────^──────^────────────^───────^───────
# #     _q_ quit            _<_ previous        _c_ correction
# #     ^^                  _>_ next            _d_ dictionary
# #     ^^                  _f_ check           _m_ mode
# #     ^^                  ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("<" flyspell-correct-previous :color pink)
# #     (">" flyspell-correct-next :color pink)
# #     ("c" ispell)
# #     ("d" ispell-change-dictionary)
# #     ("f" flyspell-buffer)
# #     ("m" flyspell-mode))
# # #+END_SRC

*** Hydra / TypeScript

# # Group TypeScript commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-typescript (:color blue)
# #     "
# #     ^
# #     ^TypeScript^          ^Do^
# #     ^──────────^──────────^──^────────
# #     _q_ quit             _b_ back
# #     ^^                   _e_ errors
# #     ^^                   _j_ jump
# #     ^^                   _r_ references
# #     ^^                   _R_ restart
# #     ^^                   ^^
# #     "
# #     ("q" nil)
# #     ("b" tide-jump-back)
# #     ("e" tide-project-errors)
# #     ("j" tide-jump-to-definition)
# #     ("r" tide-references)
# #     ("R" tide-restart-server))
# # #+END_SRC

*** Hydra / YASnippet

# # Group YASnippet commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-yasnippet (:color blue)
# #     "
# #     ^
# #     ^YASnippet^          ^Do^
# #     ^─────────^──────────^──^────────
# #     _q_ quit             _i_ insert
# #     ^^                   _m_ mode
# #     ^^                   _n_ new
# #     ^^                   ^^
# #     "
# #     ("q" nil)
# #     ("i" ivy-yasnippet)
# #     ("m" yas-minor-mode)
# #     ("n" yas-new-snippet))
# # #+END_SRC

*** Hydra / Windows

# # Group window-related commands.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (defhydra hydra-windows (:color pink)
# #     "
# #     ^
# #     ^Windows^           ^Window^            ^Zoom^
# #     ^───────^───────────^──────^────────────^────^──────
# #     _q_ quit            _b_ balance         _-_ out
# #     ^^                  _i_ heighten        _+_ in
# #     ^^                  _j_ narrow          _=_ reset
# #     ^^                  _k_ lower           ^^
# #     ^^                  _l_ widen           ^^
# #     ^^                  _s_ swap            ^^
# #     ^^                  ^^                  ^^
# #     "
# #     ("q" nil)
# #     ("b" balance-windows)
# #     ("i" enlarge-window)
# #     ("j" shrink-window-horizontally)
# #     ("k" shrink-window)
# #     ("l" enlarge-window-horizontally)
# #     ("s" switch-window-then-swap-buffer :color blue)
# #     ("-" text-scale-decrease)
# #     ("+" text-scale-increase)
# #     ("=" (text-scale-increase 0)))
# # #+END_SRC

** General
*** =aggressive-indent=

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package aggressive-indent
    :defer 2
    :hook ((css-mode . aggressive-indent-mode)
           (emacs-lisp-mode . aggressive-indent-mode)
           (js-mode . aggressive-indent-mode)
           (lisp-mode . aggressive-indent-mode))
    :custom (aggressive-indent-comments-too))
#+END_SRC

*** =move-text=

 Moves the current line (or if marked, the current region's, whole lines).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package move-text
    :defer 2
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down))
    :config (move-text-default-bindings))
#+END_SRC

*** =paradox=

Improved GNU Emacs standard package menu.

#+BEGIN_QUOTE
Project for modernizing Emacs' Package Menu. With improved appearance, mode-line
information. Github integration, customizability, asynchronous upgrading, and
more.

[[https://github.com/Malabarba/paradox][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paradox
    :defer 1
    :custom
    (paradox-column-width-package 27)
    (paradox-column-width-version 13)
    (paradox-execute-asynchronously t)
    (paradox-hide-wiki-packages t)
    :config
    (paradox-enable)
    (remove-hook 'paradox-after-execute-functions #'paradox--report-buffer-print))
#+END_SRC

*** =rainbow-mode=

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :defer 2
    :delight
    :hook (prog-mode))
#+END_SRC

**** Replace the current file with the saved one :notused:

Avoids call the function or reload Emacs.

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package autorevert
#     :ensure nil
#     :delight auto-revert-mode
#     :bind ("C-x R" . revert-buffer)
#     :custom (auto-revert-verbose nil)
#     :config (global-auto-revert-mode 1))
# #+END_SRC

*** =try= :notused:

Useful to temporary use a package.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package try :defer 5)
# # #+END_SRC

*** =undo-tree=

GNU Emacs's undo system allows you to recover any past state of a buffer. To do
this, Emacs treats "undo itself as another editing that can be undone".

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package undo-tree
    :delight
    :bind ("C--" . undo-tree-redo)
    :init (global-undo-tree-mode)
    :custom
    (undo-tree-visualizer-timestamps t)
    (undo-tree-visualizer-diff t))
#+END_SRC

*** =wiki-summary=

It is impossible to know everything, which is why a quick description
of a term, without breaking its workflow, is ideal.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wiki-summary
    :defer 1
    :bind ("C-c W" . wiki-summary)
    :preface
    (defun my/format-summary-in-buffer (summary)
      "Given a summary, stick it in the *wiki-summary* buffer and display the buffer"
      (let ((buf (generate-new-buffer "*wiki-summary*")))
        (with-current-buffer buf
          (princ summary buf)
          (fill-paragraph)
          (goto-char (point-min))
          (text-mode)
          (view-mode))
        (pop-to-buffer buf))))

  (advice-add 'wiki-summary/format-summary-in-buffer :override #'my/format-summary-in-buffer)
#+END_SRC

** =which-key=

It's difficult to remember all the keyboard shortcuts. The =which-key= package
helps to solve this.

I used =guide-key= in my past days, but =which-key= is a good replacement.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :defer 0.2
    :delight
    :config (which-key-mode))
#+END_SRC

** IRC :notused:

# # IRC is the best way for me to get a quick answer to a simple question and to
# # learn from more competent people than me on a subject. I'd rather use =erc= than
# # =rcirc= because I find =rcirc= very minimal.

# # Besides, for people like me, who want to store your password in a /GPG/ file,
# # you just need to specify a file priority list with =auth-sources=, to tell =erc=
# # where to start looking for your password first.

# # Of course, don't forget to add this line in your =.authinfo.gpg= file, where
# # /<nickname>/ and /<password>/ match your real information:

# # #+BEGIN_EXAMPLE
# #   machine irc.freenode.net login <nickname> password <password>
# # #+END_EXAMPLE

# # Then encrypt that file with =gpg -c .authinfo= and don't forget to delete the
# # =.authinfo= file.

# # Finally, specify to =erc= that you use a =.authinfo= file with:
# # =(setq erc-prompt-for-nickserv-password nil)=.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package erc
# #     :defer 3
# #     :delight "ε "
# #     :preface
# #     (defun my/erc-start-or-switch ()
# #       "Connects to ERC, or switch to last active buffer."
# #       (interactive)
# #       (if (get-buffer "irc.freenode.net:6667")
# #           (erc-track-switch-buffer 1)
# #         (erc :server "irc.freenode.net" :port 6667 :nick "rememberYou")))

# #     (defun my/erc-count-users ()
# #       "Displays the number of users connected on the current channel."
# #       (interactive)
# #       (if (get-buffer "irc.freenode.net:6667")
# #           (let ((channel (erc-default-target)))
# #             (if (and channel (erc-channel-p channel))
# #                 (message "%d users are online on %s"
# #                          (hash-table-count erc-channel-users)
# #                          channel)
# #               (user-error "The current buffer is not a channel")))
# #         (user-error "You must first start ERC")))

# #     (defun my/erc-notify (nickname message)
# #       "Displays a notification message for ERC."
# #       (let* ((channel (buffer-name))
# #              (nick (erc-hl-nicks-trim-irc-nick nickname))
# #              (title (if (string-match-p (concat "^" nickname) channel)
# #                         nick
# #                       (concat nick " (" channel ")")))
# #              (msg (s-trim (s-collapse-whitespace message))))
# #         (alert (concat nick ": " msg) :title title)))

# #     (defun my/erc-preprocess (string)
# #       "Avoids channel flooding."
# #       (setq str
# #             (string-trim
# #              (replace-regexp-in-string "\n+" " " str))))
# #     :hook ((ercn-notify . my/erc-notify)
# #            (erc-send-pre . my/erc-preprocess))
# #     :custom-face
# #     (erc-action-face ((t (:foreground "#8fbcbb"))))
# #     (erc-error-face ((t (:foreground "#bf616a"))))
# #     (erc-input-face ((t (:foreground "#ebcb8b"))))
# #     (erc-notice-face ((t (:foreground "#ebcb8b"))))
# #     (erc-timestamp-face ((t (:foreground "#a3be8c"))))
# #     :custom
# #     (erc-autojoin-channels-alist '(("freenode.net" "#archlinux" "#bash" "##c++"
# #                                     "#emacs""#i3" "#latex" "#org-mode" "#python"
# #                                     "#qutebrowser" "#reactjs" "#sway")))
# #     (erc-autojoin-timing 'ident)
# #     (erc-fill-function 'erc-fill-static)
# #     (erc-fill-static-center 22)
# #     (erc-header-line-format "%n on %t (%m)")
# #     (erc-hide-list '("JOIN" "PART" "QUIT"))
# #     (erc-join-buffer 'bury)
# #     (erc-kill-buffer-on-part t)
# #     (erc-kill-queries-on-quit t)
# #     (erc-kill-server-buffer-on-quit t)
# #     (erc-lurker-hide-list '("JOIN" "PART" "QUIT"))
# #     (erc-lurker-threshold-time 43200)
# #     (erc-prompt-for-nickserv-password nil)
# #     (erc-server-reconnect-attempts 5)
# #     (erc-server-reconnect-timeout 3)
# #     (erc-track-exclude-types '("JOIN" "MODE" "NICK" "PART" "QUIT"
# #                                "324" "329" "332" "333" "353" "477"))
# #     :config
# #     (add-to-list 'erc-modules 'notifications)
# #     (add-to-list 'erc-modules 'spelling)
# #     (erc-services-mode 1)
# #     (erc-update-modules))

# #   (use-package erc-hl-nicks :after erc)
# #   (use-package erc-image :after erc)
# # #+END_SRC

** Ivy

I used =helm= before, but I find =ivy= faster and lighter.

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :after ivy
    :delight
    :config (counsel-mode))

  (use-package ivy
    :defer 0.1
    :delight
    :bind (("C-c C-r" . ivy-resume)
           ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (ivy-count-format "(%d/%d) ")
    (ivy-use-virtual-buffers t)
    :config (ivy-mode))

  (use-package ivy-pass
    :after ivy
    :commands ivy-pass)

  (use-package ivy-rich
    :after ivy
    :init (setq ivy-rich-parse-remote-file-path t)
    :config (ivy-rich-mode 1))

  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+END_SRC

** Navigation

This function is a mix of =C-a= and =M-m=.

From: http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
  "Moves point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

(global-set-key [remap org-beginning-of-line] #'my/smarter-move-beginning-of-line)
(global-set-key [remap move-beginning-of-line] #'my/smarter-move-beginning-of-line)
#+END_SRC

** Parenthesis

*** =rainbow-delimiters=

#+BEGIN_QUOTE
rainbow-delimiters is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their
depth. Each successive level is highlighted in a different color. This makes it
easy to spot matching delimiters, orient yourself in the code, and tell which
statements are at a given depth.

[[https://github.com/Fanael/rainbow-delimiters][Fanael Linithien]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :defer 1
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

*** =smartparens= :notused:
*NOTE:* autocreate parenthesis -> I don't like that
In my opinion, it is the most powerful package to deal with the
parenthesis. Anyway, if you don't like it, you can try taking a look at
=paredit= or =autopair=.

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package smartparens
#     :defer 1
#     :delight
#     :custom (sp-escape-quotes-after-insert nil)
#     :config (smartparens-global-mode 1))

# #+END_SRC

** Paste                                                            :notused:

#+BEGIN_QUOTE
This mode allows to paste whole buffers or parts of buffers to pastebin-like
services. It supports more than one service and will failover if one service
fails.

[[https://github.com/etu/webpaste.el][Elis Hirwing]]
#+END_QUOTE

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package webpaste
# #     :defer 3
# #     :bind (("C-c C-p C-b" . webpaste-paste-buffer)
# #            ("C-c C-p C-r" . webpaste-paste-region)))
# # #+END_SRC

# # Same principle for images with =imgbb=. This package selects an image
# # and upload it to [[https://imgbb.com/][imgbb]], making sure to display the URL of the image in
# # the minibuffer and place it in the kill ring.

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package imgbb :defer 2)
# # #+END_SRC

** PDF :notused:
#+BEGIN_QUOTE
PDF Tools is, among other things, a replacement of DocView for PDF files. The
key difference is that pages are not pre-rendered by e.g. ghostscript and stored
in the file-system, but rather created on-demand and stored in memory.

[[https://github.com/politza/pdf-tools][Andras Politz]]
#+END_QUOTE

# #+BEGIN_SRC emacs-lisp :tangle yes
#   (use-package pdf-tools
#     :defer 1
#     :init (pdf-tools-install :no-query))

#   (use-package pdf-view
#     :ensure nil
#     :after pdf-tools
#     :bind (:map pdf-view-mode-map
#                 ("C-s" . isearch-forward)
#                 ("d" . pdf-annot-delete)
#                 ("h" . pdf-annot-add-highlight-markup-annotation)
#                 ("t" . pdf-annot-add-text-annotation))
#     :custom
#     (pdf-view-display-size 'fit-page)
#     (pdf-view-resize-factor 1.1)
#     (pdf-view-use-unicode-ligther nil))
# #+END_SRC

** Point and Region

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :defer 2
    :bind (("C-+" . er/contract-region)
           ("C-=" . er/expand-region)))
#+END_SRC

I find useful to delete a line and a region with only =C-w=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
#+END_SRC

** Projectile :notused:

# # #+BEGIN_QUOTE
# # Projectile is a project interaction library for Emacs. Its goal is to provide a
# # nice set of features operating on a project level without introducing external
# # dependencies (when feasible). For instance - finding project files has a
# # portable implementation written in pure Emacs Lisp without the use of GNU find
# # (but for performance sake an indexing mechanism backed by external commands
# # exists as well).

# # [[https://github.com/bbatsov/projectile][Bozhidar Batsov]]
# # #+END_QUOTE

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package projectile
# #     :defer 1
# #     :custom
# #     (projectile-cache-file (expand-file-name "~/.emacs.d/projectile.cache" ))
# #     (projectile-completion-system 'ivy)
# #     (projectile-enable-caching t)
# #     (projectile-known-projects-file (expand-file-name "~/.emacs.d/projectile-bookmarks.eld" ))
# #     (projectile-mode-line '(:eval (projectile-project-name)))
# #     :config (projectile-global-mode))

# #   (use-package counsel-projectile
# #     :after (counsel projectile)
# #     :config (counsel-projectile-mode 1))
# # #+END_SRC

** Recent Files

Provides fast access to the recent files.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package recentf
    :defer 2
    :bind ("C-c r" . recentf-open-files)
    :init (recentf-mode)
    :custom
    (recentf-exclude (list "COMMIT_EDITMSG"
                           "~$"
                           "/scp:"
                           "/ssh:"
                           "/sudo:"
                           "/tmp/"))
    (recentf-max-menu-items 15)
    (recentf-max-saved-items 200)
    (recentf-save-file "~/.emacs.d/recentf" )
    :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+END_SRC

** Whitespaces

It is often annoying to see unnecessary blank spaces at the end of a line or file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package whitespace
    :defer 1
    :hook (before-save . delete-trailing-whitespace))
#+END_SRC

*** =hungry-delete=

# # #+BEGIN_QUOTE
# # Deleting a whitespace character will delete all whitespace until the next
# # non-whitespace character.

# # [[https://github.com/nflath/hungry-delete][Nathaniel Flath]]
# # #+END_QUOTE

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package hungry-delete
# #     :defer 0.7
# #     :delight
# #     :config (global-hungry-delete-mode))
# # #+END_SRC

** Windows

Don't ask before killing a buffer. I know what I'm doing.

#+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key [remap kill-buffer] #'kill-this-buffer)
#+END_SRC

*** =switch-window=

Displays an overlay in each window showing a unique key, then asks the user
where to move in the window.

Most people use =ace-window=, but I prefer =switch-window= because I find this
package more ergonomic by using the fact of displaying the buffer number by
hiding its contents.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package switch-window
    :defer 0.2
    :bind (("C-x o" . switch-window)
           ("C-x w" . switch-window-then-swap-buffer)))
#+END_SRC

*** =windmove=

# # Allows you to move from one window to another with something more natural than
# # cycling through =C-x o= (=other-window=).

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package windmove
# #     :defer 0.2
# #     :bind (("C-c h" . windmove-left)
# #            ("C-c j" . windmove-down)
# #            ("C-c k" . windmove-up)
# #            ("C-c l" . windmove-right)))
# # #+END_SRC

*** =winner=

# # I often undo's and redo's with window configurations.

# # #+BEGIN_QUOTE
# # Winner mode is a global minor mode that records the changes in the window
# # configuration (i.e. how the frames are partitioned into windows) so that the
# # changes can be "undone" using the command =winner-undo=. By default this one is
# # bound to the key sequence ctrl-c left. If you change your mind (while undoing),
# # you can press ctrl-c right (calling =winner-redo=).

# # [[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
# # #+END_QUOTE

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package winner
# #     :defer 2
# #     :config (winner-mode 1))
# # #+END_SRC

** Word Wrap

I like to have lines of the same length.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :delight (auto-fill-function)
    :bind ("C-x p" . pop-to-mark-command)
    :hook ((prog-mode . turn-on-auto-fill)
           (text-mode . turn-on-auto-fill))
    :custom (set-mark-command-repeat-pop t))
#+END_SRC

** YASnippet

# # #+BEGIN_QUOTE
# # YASnippet is a template system for Emacs. It allows you to type an abbreviation
# # and automatically expand it into function templates.

# # [[https://github.com/joaotavora/yasnippet][João Távora]]
# # #+END_QUOTE

# # #+BEGIN_SRC emacs-lisp :tangle yes
# #   (use-package yasnippet
# #     :defer 1
# #     :delight yas-minor-mode " υ"
# #     :hook (yas-minor-mode . my/disable-yas-if-no-snippets)
# #     :config (yas-global-mode)
# #     :preface
# #     (defun my/disable-yas-if-no-snippets ()
# #       (when (and yas-minor-mode (null (yas--get-snippet-tables)))
# #         (yas-minor-mode -1))))

# #   (use-package yasnippet-snippets
# #     :after yasnippet
# #     :config (yasnippet-snippets-initialize))

# #   (use-package ivy-yasnippet :after yasnippet)
# #   (use-package react-snippets :after yasnippet)
# # #+END_SRC

* Major mode
** Languages
*** Emacs Lisp
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package elisp-mode :ensure nil :delight "ξ ")
 #+END_SRC
**** Eldoc

 Provides minibuffer hints when working with Emacs Lisp.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package eldoc
     :delight
     :hook (emacs-lisp-mode . eldoc-mode))
 #+END_SRC

*** Markdown
 Before you can use this package, make sure you install =markdown= on your
 operating system.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package markdown-mode
     :delight "μ "
     :mode ("INSTALL\\'"
            "CONTRIBUTORS\\'"
            "LICENSE\\'"
            "README\\'"
            "\\.markdown\\'"
            "\\.md\\'"))
 #+END_SRC

*** LaTeX

 I use LaTeX for my reports, CVs, summaries, etc.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package tex
     :ensure auctex
     :hook (LaTeX-mode . reftex-mode)
     :custom
     (TeX-PDF-mode t)
     (TeX-auto-save t)
     (TeX-byte-compile t)
     (TeX-clean-confirm nil)
     (TeX-master 'dwim)
     (TeX-parse-self t)
     (TeX-source-correlate-mode t)
     (TeX-view-program-selection '((output-pdf "Evince")
                                   (output-html "xdg-open"))))

   (use-package bibtex
     :after auctex
     :hook (bibtex-mode . my/bibtex-fill-column)
     :preface
     (defun my/bibtex-fill-column ()
       "Ensures that each entry does not exceed 120 characters."
       (setq fill-column 120)))

   (use-package company-auctex
     :after (auctex company)
     :config (company-auctex-init))

   (use-package company-math :after (auctex company))
 #+END_SRC

 I want a TeX engine that can deal with Unicode and use any font I like.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (setq-default TeX-engine 'xetex)
 #+END_SRC

**** =reftex=

 Minor mode with distinct support for \label, \ref and \cite in LaTeX.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package reftex :after auctex)
 #+END_SRC
** Ledger                                                           :notused:

 #+BEGIN_QUOTE
 Ledger is a powerful, double-entry accounting system that is accessed from the
 UNIX command-line.

 [[https://github.com/ledger/ledger][John Wiegley]]
 #+END_QUOTE

 Before you can use this configuration, make sure you install =ledger= on your
 operating system.

 Now all we have to do is configure =ledger-mode=:

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package ledger-mode
     :ensure-system-package (ledger . "trizen -S --noconfirm ledger")
     :mode ("\\.dat\\'"
            "\\.ledger\\'")
     :bind (:map ledger-mode-map
                 ("C-x C-s" . my/ledger-save))
     :hook (ledger-mode . ledger-flymake-enable)
     :preface
     (defun my/ledger-save ()
       "Automatically clean the ledger buffer at each save."
       (interactive)
       (ledger-mode-clean-buffer)
       (save-buffer))
     :custom
     (ledger-clear-whole-transactions t)
     (ledger-reconcile-default-commodity "EUR")
     (ledger-reports
      '(("account statement" "%(binary) reg --real [[ledger-mode-flags]] -f %(ledger-file) ^%(account)")
        ("balance sheet" "%(binary) --real [[ledger-mode-flags]] -f %(ledger-file) bal ^assets ^liabilities ^equity")
        ("budget" "%(binary) --empty -S -T [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:budget")
        ("budget goals" "%(binary) --empty -S -T [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:'budget goals'")
        ("budget obligations" "%(binary) --empty -S -T [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:'budget obligations'")
        ("budget debts" "%(binary) --empty -S -T [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:'budget debts'")
        ("cleared" "%(binary) cleared [[ledger-mode-flags]] -f %(ledger-file)")
        ("equity" "%(binary) --real [[ledger-mode-flags]] -f %(ledger-file) equity")
        ("income statement" "%(binary) --invert --real -S -T [[ledger-mode-flags]] -f %(ledger-file) bal ^income ^expenses -p \"this month\""))
      (ledger-report-use-header-line nil)))

      (use-package flycheck-ledger :after ledger-mode)
 #+END_SRC

 *NOTE:* by default, =ledger= uses the [[ https://xkcd.com/1179/][ISO 8601]] format to write dates, which is the recommended
 # # format.

** Org

 # # One of my favorite modes in GNU Emacs. I mainly use it to organize my life, take
 # # notes and make my presentations, but you can do lots of things with
 # # it. =org-mode= it's like the sky, without limits.

 # # #+BEGIN_QUOTE
 # # Org mode is for keeping notes, maintaining TODO lists, planning projects, and
 # # authoring documents with a fast and effective plain-text system.

 # # [[http://orgmode.org/][Carsten Dominik]]
 # # #+END_QUOTE

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org
 # #     :ensure org-plus-contrib
 # #     :delight "Θ "
 # #     :preface
 # #     (defun my/org-compare-times (clocked estimated)
 # #       "Gets the ratio between the timed time and the estimated time."
 # #       (if (and (> (length clocked) 0) estimated)
 # #           (format "%.2f"
 # #                   (/ (* 1.0 (org-hh:mm-string-to-minutes clocked))
 # #                      (org-hh:mm-string-to-minutes estimated)))
 # #         ""))

 # #     (defun my/org-archive-done-tasks ()
 # #       "Archives finished or cancelled tasks."
 # #       (interactive)
 # #       (org-map-entries
 # #        (lambda ()
 # #          (org-archive-subtree)
 # #          (setq org-map-continue-from (outline-previous-heading)))
 # #        "TODO=\"DONE\"|TODO=\"CANCELLED\"" (if (org-before-first-heading-p) 'file 'tree)))

 # #     (defun my/org-jump ()
 # #       "Jumps to a specific task."
 # #       (interactive)
 # #       (let ((current-prefix-arg '(4)))
 # #         (call-interactively 'org-refile)))

 # #     (defun my/org-use-speed-commands-for-headings-and-lists ()
 # #       "Activates speed commands on list items too."
 # #       (or (and (looking-at org-outline-regexp) (looking-back "^\**"))
 # #           (save-excursion (and (looking-at (org-item-re)) (looking-back "^[ \t]*")))))
 # #     :hook ((after-save . my/config-tangle)
 # #            (auto-save . org-save-all-org-buffer)
 # #            (org-mode . org-indent-mode))
 # #     :custom
 # #     (org-archive-location "~/.personal/archives/%s::")
 # #     (org-blank-before-new-entry '((heading . t)
 # #                                   (plain-list-item . t)))
 # #     (org-cycle-include-plain-lists 'integrate)
 # #     (org-ditaa-jar-path "~/.local/lib/ditaa0_9.jar")
 # #     (org-expiry-inactive-timestamps t)
 # #     (org-export-backends '(ascii beamer html icalendar latex man md org texinfo))
 # #     (org-log-done 'time)
 # #     (org-log-into-drawer "LOGBOOK")
 # #     (org-modules '(org-crypt
 # #                    org-habit
 # #                    org-info
 # #                    org-irc
 # #                    org-mouse
 # #                    org-protocol))
 # #     (org-refile-allow-creating-parent-nodes 'confirm)
 # #     (org-refile-use-cache nil)
 # #     (org-refile-use-outline-path nil)
 # #     (org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
 # #     (org-startup-folded nil)
 # #     (org-startup-with-inline-images t)
 # #     (org-tag-alist '(("@coding" . ?c)
 # #                      ("@computer" . ?l)
 # #                      ("@errands" . ?e)
 # #                      ("@home" . ?h)
 # #                      ("@phone" . ?p)
 # #                      ("@reading" . ?r)
 # #                      ("@school" . ?s)
 # #                      ("@work" . ?b)
 # #                      ("@writing" . ?w)
 # #                      ("crypt" . ?C)
 # #                      ("fuzzy" . ?0)
 # #                      ("highenergy" . ?1)))
 # #     (org-tags-exclude-from-inheritance '("crypt" "project"))
 # #     (org-todo-keywords '((sequence "TODO(t)"
 # #                                    "STARTED(s)"
 # #                                    "WAITING(w@/!)"
 # #                                    "SOMEDAY(.)" "|" "DONE(x!)" "CANCELLED(c@)")
 # #                          (sequence "TOBUY"
 # #                                    "TOSHRINK"
 # #                                    "TOCUT"
 # #                                    "TOSEW" "|" "DONE(x)")))
 # #     (org-use-effective-time t)
 # #     (org-use-speed-commands 'my/org-use-speed-commands-for-headings-and-lists)
 # #     (org-yank-adjusted-subtrees t)
 # #     :config
 # #     (add-to-list 'org-global-properties '("Effort_ALL". "0:05 0:15 0:30 1:00 2:00 3:00 4:00"))
 # #     (add-to-list 'org-speed-commands-user '("!" my/org-clock-in-and-track))
 # #     (add-to-list 'org-speed-commands-user '("$" call-interactively 'org-archive-subtree))
 # #     (add-to-list 'org-speed-commands-user '("d" my/org-move-line-to-destination))
 # #     (add-to-list 'org-speed-commands-user '("i" call-interactively 'org-clock-in))
 # #     (add-to-list 'org-speed-commands-user '("o" call-interactively 'org-clock-out))
 # #     (add-to-list 'org-speed-commands-user '("s" call-interactively 'org-schedule))
 # #     (add-to-list 'org-speed-commands-user '("x" org-todo "DONE"))
 # #     (add-to-list 'org-speed-commands-user '("y" org-todo-yesterday "DONE"))
 # #     (org-clock-persistence-insinuate)
 # #     (org-load-modules-maybe t))
 # # #+END_SRC

 If like me, you're tired of manually updating your tables of contents, =toc-org=
 will maintain a table of contents at the first heading that has a =:TOC:= tag.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package toc-org
     :after org
     :hook (org-mode . toc-org-enable))
 #+END_SRC

 For a cleaner online mode.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-indent :after org :ensure nil :delight)
 #+END_SRC

*** Agenda

 # # Nowadays, it is crucial to be organized. Even more than before. That is why it
 # # is important to take the time to make a configuration that is simple to use and
 # # that makes your life easier with an irreproachable organization.

 # # =org-agenda= allows me to be organized with daily tasks. As a result, I can use
 # # my time to the fullest.

 # # I put my =org= files in [[https://github.com/syncthing/syncthing][Syncthing]] in order to be able to check my agenda and
 # # update it from several computers and smartphones.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-agenda
 # #     :ensure nil
 # #     :after org
 # #     :bind (:map org-agenda-mode-map
 # #                 ("X" . my/org-agenda-mark-done-and-add-followup)
 # #                 ("x" . my/org-agenda-done))
 # #     :preface
 # #     (defun my/org-agenda-done (&optional arg)
 # #       "Mark current TODO as done.
 # #     This changes the line at point, all other lines in the agenda referring to
 # #     the same tree node, and the headline of the tree node in the Org-mode file."
 # #       (interactive "P")
 # #       (org-agenda-todo "DONE"))

 # #     (defun my/org-agenda-mark-done-and-add-followup ()
 # #       "Mark the current TODO as done and add another task after it.
 # #      Creates it at the same level as the previous task, so it's better to use
 # #      this with to-do items than with projects or headings."
 # #       (interactive)
 # #       (org-agenda-todo "DONE")
 # #       (org-agenda-switch-to)
 # #       (org-capture 0 "t"))
 # #     :custom
 # #     (org-agenda-dim-blocked-tasks t)
 # #     (org-agenda-files '("~/.personal/agenda"))
 # #     (org-agenda-inhibit-startup t)
 # #     (org-agenda-show-log t)
 # #     (org-agenda-skip-deadline-if-done t)
 # #     (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
 # #     (org-agenda-skip-scheduled-if-done t)
 # #     (org-agenda-span 2)
 # #     (org-agenda-start-on-weekday 6)
 # #     (org-agenda-sticky nil)
 # #     (org-agenda-tags-column -100)
 # #     (org-agenda-time-grid '((daily today require-timed)))
 # #     (org-agenda-use-tag-inheritance t)
 # #     (org-columns-default-format "%14SCHEDULED %Effort{:} %1PRIORITY %TODO %50ITEM %TAGS")
 # #     (org-default-notes-file "~/.personal/agenda/organizer.org")
 # #     (org-directory "~/.personal")
 # #     (org-enforce-todo-dependencies t)
 # #     (org-habit-graph-column 80)
 # #     (org-habit-show-habits-only-for-today nil)
 # #     (org-track-ordered-property-with-tag t))
 # # #+END_SRC

*** Bullets

 # # Prettier [[https://github.com/sabof/org-bullets][bullets]] in org-mode.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-bullets
 # #     :hook (org-mode . org-bullets-mode)
 # #     :custom (org-bullets-bullet-list '("●" "▲" "■" "✶" "◉" "○" "○")))
 # # #+END_SRC

*** Capture

 # # =org-capture= templates saves you a lot of time when adding new entries. I use
 # # it to quickly record tasks, ledger entries, notes and other semi-structured
 # # information.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-capture
 # #     :ensure nil
 # #     :after org
 # #     :preface
 # #     (defvar my/org-basic-task-template "* TODO %^{Task}
 # #   :PROPERTIES:
 # #   :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
 # #   :END:
 # #   Captured %<%Y-%m-%d %H:%M>" "Template for basic task.")

 # #     (defvar my/org-contacts-template "* %(org-contacts-template-name)
 # #   :PROPERTIES:
 # #   :ADDRESS: %^{289 Cleveland St. Brooklyn, 11206 NY, USA}
 # #   :BIRTHDAY: %^{yyyy-mm-dd}
 # #   :EMAIL: %(org-contacts-template-email)
 # #   :NOTE: %^{NOTE}
 # #   :END:" "Template for org-contacts.")

 # #     (defvar my/org-ledger-card-template "%(org-read-date) %^{Payee}
 # #     Expenses:%^{Account}  €%^{Amount}
 # #     Liabilities:CreditsCards:Belfius" "Template for credit card transaction with ledger.")

 # #     (defvar my/org-ledger-cash-template "%(org-read-date) * %^{Payee}
 # #     Expenses:%^{Account}  €%^{Amount}
 # #     Assets:Cash:Wallet" "Template for cash transaction with ledger.")
 # #     :custom
 # #     (org-capture-templates
 # #      `(("B" "Book" checkitem (file+headline "~/.personal/other/books.org" "Books")
 # #         "- [ ] %^{Book}"
 # #         :immediate-finish t)

 # #        ("L" "Learning" checkitem (file+headline "~/.personal/other/learning.org" "Things")
 # #         "- [ ] %^{Thing}"
 # #         :immediate-finish t)

 # #        ("M" "Movie" checkitem (file+headline "~/.personal/other/movies.org" "Movies")
 # #         "- [ ] %^{Movie}"
 # #         :immediate-finish t)

 # #        ("P" "Purchase" checkitem (file+headline "~/.personal/other/purchases.org" "Purchases")
 # #         "- [ ] %^{Item}"
 # #         :immediate-finish t)

 # #        ("c" "Contact" entry (file+headline "~/.personal/agenda/contacts.org" "Friends"),
 # #         my/org-contacts-template
 # #         :empty-lines 1)

 # #        ("l" "Ledger")

 # #        ("lb" "Bank" plain (file ,(format "~/.personal/ledger/ledger-%s.dat" (format-time-string "%Y"))),
 # #         my/org-ledger-card-template
 # #         :empty-lines 1
 # #         :immediate-finish t)

 # #        ("lc" "Cash" plain (file ,(format "~/.personal/ledger/ledger-%s.dat" (format-time-string "%Y"))),
 # #         my/org-ledger-cash-template
 # #         :empty-lines 1
 # #         :immediate-finish t)

 # #        ("f" "FindMyCat" entry (file+headline "~/.personal/agenda/findmycat.org" "Tasks"),
 # #         my/org-basic-task-template
 # #         :empty-lines 1)

 # #        ("p" "People" entry (file+headline "~/.personal/agenda/people.org" "Tasks"),
 # #         my/org-basic-task-template
 # #         :empty-lines 1)

 # #        ("s" "School" entry (file+headline "~/.personal/agenda/school.org" "Tasks"),
 # #         my/org-basic-task-template
 # #         :empty-lines 1)

 # #        ("t" "Task" entry (file+headline "~/.personal/agenda/organizer.org" "Tasks"),
 # #         my/org-basic-task-template
 # #         :empty-lines 1))))
 # # #+END_SRC

*** Clock

 # # Being organized is one thing, but being optimal is another. =org-clock= allows
 # # you to estimate your tasks and time them. This is useful, since with experience,
 # # you can have a better estimate of the time that needs to be given to each task.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-clock
 # #     :ensure nil
 # #     :after org
 # #     :preface
 # #     (defun my/org-mode-ask-effort ()
 # #       "Ask for an effort estimate when clocking in."
 # #       (unless (org-entry-get (point) "Effort")
 # #         (let ((effort
 # #                (completing-read
 # #                 "Effort: "
 # #                 (org-entry-get-multivalued-property (point) "Effort"))))
 # #           (unless (equal effort "")
 # #             (org-set-property "Effort" effort)))))
 # #     :hook (org-clock-in-prepare-hook . my/org-mode-ask-effort)
 # #     :custom
 # #     (org-clock-clocktable-default-properties
 # #      '(:block day :maxlevel 2 :scope agenda :link t :compact t :formula %
 # #               :step day :fileskip0 t :stepskip0 t :narrow 80
 # #               :properties ("Effort" "CLOCKSUM" "CLOCKSUM_T" "TODO")))
 # #     (org-clock-continuously nil)
 # #     (org-clock-in-switch-to-state "STARTED")
 # #     (org-clock-out-remove-zero-time-clocks t)
 # #     (org-clock-persist t)
 # #     (org-clock-persist-file (expand-file-name (format "%s/emacs/org-clock-save.el" xdg-cache)))
 # #     (org-clock-persist-query-resume nil)
 # #     (org-clock-report-include-clocking-task t)
 # #     (org-show-notification-handler (lambda (msg) (alert msg))))
 # # #+END_SRC

*** Contacts

 # # The best solution to maintain your contacts. I tend to use =org-contacts= to
 # # remember their birthdays so I can be the first to wish them that. Be careful
 # # that to install it, this one is available with =org-plus-contrib=.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-contacts
 # #     :ensure nil
 # #     :after org
 # #     :custom (org-contacts-files '("~/.personal/agenda/contacts.org")))
 # # #+END_SRC

*** Custormization

 # # Let's change the foreground and the weight of each keywords.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-faces
 # #     :ensure nil
 # #     :after org
 # #     :custom
 # #     (org-todo-keyword-faces
 # #      '(("DONE" . (:foreground "cyan" :weight bold))
 # #        ("SOMEDAY" . (:foreground "gray" :weight bold))
 # #        ("TODO" . (:foreground "green" :weight bold))
 # #        ("WAITING" . (:foreground "red" :weight bold)))))
 # # #+END_SRC

*** Encryption / Decryption

 # # To be able to enable encryption and decryption of =.gpg= files with =org-mode=,
 # # we will need to install =gnupg2=.

 # # Once this is done, we simply configure =org-crypt= to accept our public key
 # # identifier to allow asymmetric encryption.

 *NOTE:* you need to modify the =org-crypt-key= variable to replace my key
 # # identifier, by yours (or =nil= to allow symmetric encryption).

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-crypt
 # #     :ensure nil
 # # 	:after org
 # #     :init (org-crypt-use-before-save-magic)
 # #     :custom (org-crypt-key "E9AADC36E94A672D1A07D49B208FCDBB98190562"))
 # # #+END_SRC

*** Journal

 # # Recently, I started writing a journal about my daily life as I read that
 # # journals improve mental claritym, help solve problems, improve overall focus,
 # # insight and understanding, track the overall development and facilitate personal
 # # growth.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-journal
 # #     :after org
 # #     :bind (("C-c t" . org-journal-new-entry)
 # #            ("C-c Y" . journal-file-yesterday))
 # #     :preface
 # #     (defun get-journal-file-yesterday ()
 # #       "Gets filename for yesterday's journal entry."
 # #       (let* ((yesterday (time-subtract (current-time) (days-to-time 1)))
 # #              (daily-name (format-time-string "%Y%m%d" yesterday)))
 # #         (expand-file-name (concat org-journal-dir daily-name))))

 # #     (defun journal-file-yesterday ()
 # #       "Creates and load a file based on yesterday's date."
 # #       (interactive)
 # #       (find-file (get-journal-file-yesterday)))
 # #     :custom
 # #     (org-journal-date-format "%e %b %Y (%A)")
 # #     (org-journal-dir "~/.personal/journal/2018/")
 # #     (org-journal-enable-encryption t)
 # #     (org-journal-file-format "%Y%m%d")
 # #     (org-journal-time-format ""))
 # # #+END_SRC

*** Languages

 # # With that, I can compile many languages with =org-mode=.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package ob-C :ensure nil :after org)
 # #   (use-package ob-css :ensure nil :after org)
 # #   (use-package ob-ditaa :ensure nil :after org)
 # #   (use-package ob-dot :ensure nil :after org)
 # #   (use-package ob-emacs-lisp :ensure nil :after org)
 # #   (use-package ob-gnuplot :ensure nil :after org)
 # #   (use-package ob-java :ensure nil :after org)
 # #   (use-package ob-js :ensure nil :after org)
 # #   (use-package ob-latex :ensure nil :after org)
 # #   (use-package ob-ledger :ensure nil :after org)
 # #   (use-package ob-makefile :ensure nil :after org)
 # #   (use-package ob-org :ensure nil :after org)

 # #   (use-package ob-plantuml
 # #     :ensure nil
 # #     :after org
 # #     :custom (org-plantuml-jar-path (expand-file-name (format "%s/plantuml.jar" xdg-lib))))

 # #   (use-package ob-python :ensure nil :after org)
 # #   (use-package ob-ruby :ensure nil :after org)
 # #   (use-package ob-shell :ensure nil :after org)
 # #   (use-package ob-sql :ensure nil :after org)
 # # #+END_SRC
** Gnus
#+BEGIN_SRC emacs-lisp :tangle yes
(use-package gnus
  :bind ("C-x e" . gnus)
  :custom
  (gnus-fetch-old-headers t))
;;(use-package nnir
;;  :after gnus
;;  :config
;;  (gnus-save-newsrc-file 'nil)
#+END_SRC
** Magit

It is quite common to work on Git repositories, so it is important to have a
configuration that we like.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Magit]] is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

[[https://github.com/tarsius][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
     :defer 0.3
     :bind ("C-x g" . magit-status)
  )
  (use-package git-commit
    :after magit
    :hook (git-commit-mode . my/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 50)
    :preface
    (defun my/git-commit-auto-fill-everywhere ()
      "Ensures that the commit body does not exceed 72 characters."
      (setq fill-column 72)
      (setq-local comment-auto-fill-only-comments nil)))
#+END_SRC

In addition to that, I like to see the lines that are being modified in the file
while it is being edited.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :defer 0.3
    :delight
    :init (global-git-gutter-mode +1))
#+END_SRC

Finally, one last package that I like to use with Git to easily see the changes
made by previous commits.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-timemachine :defer 1 :delight)
#+END_SRC
** Dired

For those who didn't know, GNU Emacs is also a file explorer.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired
    :ensure nil
    :delight "Dired "
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-listing-switches "-alh")
    (dired-ls-F-marks-symlinks nil)
    (dired-recursive-copies 'always))

  (use-package dired-x
    :ensure nil
    :preface
    (defun my/dired-revert-after-cmd (command &optional output error)
      (revert-buffer))
    :config (advice-add 'dired-smart-shell-command :after #'my/dired-revert-after-cmd))
#+END_SRC
