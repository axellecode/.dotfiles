#+AUTHOR: Sylvain Ribstein
#+TITLE: GNU Emacs Configuration

* table of content                                                    :TOC@2:
- [[#customisation][Customisation]]
  - [[#packages][Packages]]
  - [[#authentification][Authentification]]
  - [[#defaults-values][defaults values]]
  - [[#customization-interface][Customization interface]]
  - [[#backups][Backups]]
  - [[#apparence][apparence]]
- [[#major-mode][Major mode]]
  - [[#pdf][PDF]]
  - [[#languages][Languages]]
  - [[#budger-ledger][Budger =ledger=]]
  - [[#todo-agenda-org-mode][Todo, agenda =org-mode=]]
  - [[#mail-gnus][Mail =gnus=]]
  - [[#contact-bbdb][Contact =bbdb=]]
  - [[#git][Git]]
  - [[#file-explorer-dired][File Explorer =dired=]]
  - [[#password-store-pass][password-store =pass=]]
  - [[#game][Game]]
  - [[#typing-training][Typing training]]
  - [[#shell-eshell][Shell =eshell=]]
  - [[#social-acount][social acount]]
- [[#minor-mode][Minor mode]]
  - [[#auto-completion-company][Auto-Completion =company=]]
  - [[#internet-interface][Internet interface]]
  - [[#dashboard][Dashboard]]
  - [[#reset-config-when-configorg-changes][reset config when config.org changes]]
  - [[#history-savehist][History =savehist=]]
  - [[#improved-package-menu-paradox][improved package menu =paradox=]]
  - [[#text-formatting][Text formatting]]
  - [[#text-editing][Text editing]]
  - [[#keystroke-which-key][keystroke =which-key=]]
  - [[#autocompletion-ivy][autocompletion =Ivy=]]
  - [[#m-x-enhancement-smex][M-x enhancement =smex=]]
  - [[#text-navigation][Text Navigation]]
  - [[#point-and-region][Point and Region]]
  - [[#recent-files][Recent Files]]
  - [[#buffer-and-windows][Buffer and Windows]]
  - [[#word-wrap-simple][Word Wrap =simple=]]
  - [[#custom-fonction][custom fonction]]
  - [[#project-management][Project management]]

* Customisation
** Packages
***  Sources
   In order to install packages, it is useful to configure the package sources.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq package-archives
  '(("melpa" . "http://melpa.org/packages/")
     ("gnu" . "http://elpa.gnu.org/packages/") ;; is it still used ?
     ("org" . "http://orgmode.org/elpa/")
     ("marmalade" . "http://marmalade-repo.org/packages/")
  ))
#+END_SRC
*** package manager =use-package=
   To be able to manage its configuration with =use-package= it is necessary to
   first install it, if you don't already.
   *NOTE:* Need to understand if it use also the package manager of emacs
   Also ensure that the package is installed and if not tries to install it.

#+BEGIN_SRC emacs-lisp :tangle yes
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))
  (use-package use-package-ensure-system-package :ensure t)
#+END_SRC

** Authentification
   In which file the authentification is save
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq auth-sources '( "~/.authinfo.gpg" ))
#+END_SRC
** defaults values
For a better user experience of GNU Emacs, here are the default values I use.
#+BEGIN_SRC emacs-lisp :tangle yes
(setq-default
  ad-redefinition-action 'accept                   ; Silence warnings for redefinition
  cursor-in-non-selected-windows t                 ; Hide the cursor in inactive windows
  display-time-default-load-average nil            ; Don't display load average
  fill-column 80                                   ; Set width for automatic line breaks
  help-window-select t                             ; Focus new help windows when opened
  inhibit-startup-screen t                         ; Disable start-up screen
  initial-scratch-message ""                       ; Empty the initial *scratch* buffer
  kill-ring-max 128                                ; Maximum length of kill ring
  load-prefer-newer t                              ; Prefers the newest version of a file
  mark-ring-max 128                                ; Maximum length of mark ring
  scroll-conservatively most-positive-fixnum       ; Always scroll by one line
  select-enable-clipboard t                        ; Merge system's and Emacs' clipboard
  x-select-enable-clipboard t                      ; enable copy pas to classic clipboard
  tab-width 4                                      ; Set width for tabs
  use-package-always-ensure t                      ; Avoid the :ensure keyword for each package
  user-full-name "Sylvain Ribstein"                ; Set the full name of the current user
  user-mail-address "sylvain.ribstein@gmail.com"   ; Set the email address of the current user
  vc-follow-symlinks t                             ; Always follow the symlinks
  view-read-only t                                 ; Always open read-only buffers in view-mode
  blink-cursor-mode nil                            ; the cursor wont blink
  indent-tabs-mode nil)                            ; use space instead of tab to indent
 (delete-selection-mode t)                        ; when writing into marked region delete it
 (transient-mark-mode t)                          ; same mark mouse or keyboard
 (cd "~/")                                        ; Move to the user directory
 (column-number-mode 1)                           ; Show the column number
 (display-time-mode 1)                            ; Enable time in the mode-line
 (fset 'yes-or-no-p 'y-or-n-p)                    ; Replace yes/no prompts with y/n
 (global-hl-line-mode)                            ; Hightlight current line
 (set-default-coding-systems 'utf-8)              ; Default to utf-8 encoding
 (show-paren-mode 1)                              ; Show the parenthesis
 (put 'upcase-region 'disabled nil)               ; Allow C-x C-u
 (put 'downcase-region 'disabled nil)             ; Allow C-x C-l
#+END_SRC

** Customization interface
   To avoid overloading the GNU Emacs custormization =init.el= file made by the
   user with the UI, I add the generated code in a separate file.
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq-default custom-file (expand-file-name "~/.emacs.d/custom.el"))
  (when (file-exists-p custom-file)
    (load custom-file t))
#+END_SRC
** Backups
   It is important to have a stable backup environment. Don't hesitate to save a
   lot.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package files
    :ensure nil
    :custom
    (backup-directory-alist `(("." . "~/.emacs.d/backup")))
    (delete-old-versions -1)
    (vc-make-backup-files t)
    (version-control t))
#+END_SRC


** apparence
*** Theme
   [[https://github.com/emacsfodder/emacs-soothe-theme][soothe]] est un theme assez doux
#+BEGIN_SRC emacs-lisp :tangle yes
       ;; (use-package soothe-theme)
     (use-package xresources-theme
     ;; :when window-system
       :hook ('after-make-frame-functions .
              (lambda (frame)
                 (when (eq (length (frame-list)) 2)
                    (progn
                    (select-frame frame)
                    (load-theme 'xresources)))))
       :config
    ;; xresources-theme set hl-line to be the same color as the background...
       (set-face-background 'hl-line (x-get-resource "color8" ""))
       )

#+END_SRC

*** transparent
    Cannot make it work not sur to see why
#+BEGIN_SRC emacs-lisp :tangle yes
;;emacs transparency
(set-frame-parameter (selected-frame) 'alpha '(85 60))
(add-to-list 'default-frame-alist '(alpha 85 60))

(eval-when-compile (require 'cl))
(defun toggle-transparency ()
  (interactive)
  (if (/=
       (cadr (frame-parameter nil 'alpha))
       100)
      (set-frame-parameter nil 'alpha '(100 100))
    (set-frame-parameter nil 'alpha '(90 60))))
(global-set-key (kbd "C-c g") 'toggle-transparency)

;; Set transparency of emacs
(defun transparency (arg &optional active)
  "Sets the transparency of the frame window. 0=transparent/100=opaque"
  (interactive "Enter alpha value (1-100): \np")
  (let* ((elt (assoc 'alpha default-frame-alist))
         (old (frame-parameter nil 'alpha))
         (new (cond ((atom old)     `(,arg ,arg))
                    ((eql 1 active) `(,arg ,(cadr old)))
                    (t              `(,(car old) ,arg)))))
    (if elt (setcdr elt new) (push `(alpha ,@new) default-frame-alist))
    (set-frame-parameter nil 'alpha new)))
(global-set-key (kbd "C-c G") 'transparency)
#+END_SRC
*** =delight=
   delight is a way of showing wich major/minor is currently open
   It's show which mode on the main bar
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package delight :ensure t)
#+END_SRC
*** Turn off mouse interface
   Since I never use the mouse with GNU Emacs, I prefer not to use certain
   graphical elements as seen as the menu bar, toolbar, scrollbar and tooltip that
   I find invasive.
#+BEGIN_SRC emacs-lisp :tangle yes
    (menu-bar-mode -1)                              ; Disable the menu bar
    (scroll-bar-mode -1)                            ; Disable the scroll bar
    (tool-bar-mode -1)                              ; Disable the tool bar
    (tooltip-mode -1)                               ; Disable the tooltips
#+END_SRC
*** unicode icons ==all-the-icons=
#+BEGIN_SRC emacs-lisp :tangle yes
     (use-package all-the-icons)
  ;; (use-package all-the-icons-dired :hook dired-mode)
  ;;   (use-package all-the-icons-gnus
  ;;   :hook gnus)
  ;;   (use-package all-the-icons-ivy)
#+END_SRC

* Major mode
** PDF
#+BEGIN_QUOTE
PDF Tools is, among other things, a replacement of DocView for PDF files. The
key difference is that pages are not pre-rendered by e.g. ghostscript and stored
in the file-system, but rather created on-demand and stored in memory.
[[https://github.com/politza/pdf-tools][Andras Politz]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
   ;; (use-package pdf-tools
   ;;   :mode "\\.pdf\\"
   ;;   :init (pdf-tools-install :no-query))

   ;; (use-package pdf-view
   ;;   :ensure nil
   ;;   :after pdf-tools
   ;;   :bind (:map pdf-view-mode-map
   ;;               ("C-s" . isearch-forward)
   ;;               ("d" . pdf-annot-delete)
   ;;               ("h" . pdf-annot-add-highlight-markup-annotation)
   ;;               ("t" . pdf-annot-add-text-annotation))
   ;;   :custom
   ;;   (pdf-view-display-size 'fit-page)
   ;;   (pdf-view-resize-factor 1.1)
   ;;   (pdf-view-use-unicode-ligther nil))
 #+End_SRC

** Languages
   test test
*** Emacs Lisp
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package elisp-mode :ensure nil :delight "ξ ")
 #+END_SRC
**** Eldoc

 Provides minibuffer hints when working with Emacs Lisp.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package eldoc
     :delight
     :hook (emacs-lisp-mode . eldoc-mode))
 #+END_SRC

*** Markdown
 Before you can use this package, make sure you install =markdown= on your
 operating system.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package markdown-mode
     :delight "μ "
     :mode ("INSTALL\\'"
            "CONTRIBUTORS\\'"
            "LICENSE\\'"
            "README\\'"
            "\\.markdown\\'"
            "\\.md\\'"))
 #+END_SRC

*** LaTeX
 I use LaTeX for my reports, CVs, summaries, etc.

 #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package tex
        :ensure auctex
        :hook (LaTeX-mode . reftex-mode)
        :custom
        (TeX-PDF-mode t)
        (TeX-auto-save t)
        (TeX-byte-compile t)
        (TeX-clean-confirm nil)
        (TeX-master 'dwim)
        (TeX-parse-self t)
        (TeX-source-correlate-mode t)
        (TeX-view-program-selection '((output-pdf "Evince")
                                      (output-html "xdg-open"))))

      (use-package bibtex
        :after auctex
        :hook (bibtex-mode . my/bibtex-fill-column))

      ;; (use-package company-auctex
      ;;   :after (auctex company)
      ;;   :config (company-auctex-init))

      ;; (use-package company-math
      ;;     :after (auctex company))
 #+END_SRC

 #+RESULTS:

 I want a TeX engine that can deal with Unicode and use any font I like.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (setq-default TeX-engine 'xetex)
 #+END_SRC

**** =reftex=

 Minor mode with distinct support for \label, \ref and \cite in LaTeX.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package reftex :after auctex)
 #+END_SRC
*** Cobol
 #+BEGIN_SRC emacs-lisp :tangle yes
 (use-package cobol-mode
  :mode ("\\.cbl\\'" "\\.cpy\\'" "\\.pco\\'"))
 #+END_SRC
*** COQ
 #+BEGIN_SRC emacs-lisp :tangle yes
;; (eval-after-load 'proof-script
;;   '(progn
;;      ;; (define-key proof-mode-map "\M-e" 'move-end-of-line)
;;      ;; (define-key proof-mode-map "\M-a" 'move-beginning-of-line)
;;      ;; (define-key proof-mode-map "\M-n"
;;      ;;   'proof-assert-next-command-interactive)
;;      ;; (define-key proof-mode-map "\M-p"
;;      ;;   'proof-undo-last-successful-command)
;;      (define-key proof-mode-map (kbd "\C-p") 'coq-About)
;;      (define-key proof-mode-map (kbd "\C-c\C-k")
;;        'proof-goto-point)
;;      ))
;; ;; Better indent for ssreflect
;; (setq coq-one-command-per-line nil)
;; (setq coq-indent-proofstart 0)
;; (setq coq-indent-modulestart 0)
;; ;; ;; input math symbol
;; (add-hook 'proof-mode-hook (lambda () (set-input-method "TeX") ))
;; ;; Open .v files with Proof General's Coq mode
;; (require 'proof-site "~/.emacs.d/lisp/PG/generic/proof-site")
 #+END_SRC

*** OCaml
 #+BEGIN_SRC emacs-lisp :tangle yes
   ;; (setq utop-command "opam config exec -- utop -emacs")
   ;; (add-to-list 'load-path
   ;;              "/home/baroud/.opam/4.07.1+flambda/share/emacs/site-lisp")
   ;; (require 'ocp-indent)
      (setq utop-command "opam config exec -- utop -emacs")
      (add-to-list 'load-path
                   "/home/baroud/.opam/4.07.1+flambda/share/emacs/site-lisp")
       ;; (use-package ocp-indent
      ;; after:)
#+END_SRC
*** Java =jdee=
 #+BEGIN_SRC emacs-lisp :tangle yes
   ;; (use-package jdee
   ;;   :init
   ;;   (custom-set-variables '(jdee-server-dir "~/.emacs.d/jdee-server"))
   ;;   :mode "\\.java\\'"
   ;;   :custom
   ;;   (jdee-server-dir "~/bin/lib/jdee-server")
   ;; )
#+END_SRC
**** lexer/parser =antlr=
     lexer/parser generator LL(*) for java langage
  #+BEGIN_SRC emacs-lisp :tangle yes
    (use-package antlr-mode
      :mode ("\\.g4\\'"))
  #+END_SRC
**** script =groovy=
     Script version of java
     run on jvm
  #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package groovy-mode
      :mode ("\\.groovy\\'" "\\.gvy\\'" "\\.gy\\'""\\.gsh\\'" )
      :hook gradle-mode)
  #+END_SRC
**** builder =gradle=
     Gradle is a dependency manager
  #+BEGIN_SRC emacs-lisp :tangle yes
  (use-package gradle-mode
      :mode ("\\.gradle\\'")
      )

  #+END_SRC

*** Typescript
 #+BEGIN_SRC emacs-lisp :tangle yes
 (use-package typescript-mode
    :mode ("\\.ts\\'"))
 #+END_SRC

*** Yaml
    Yet another marked langage
 #+BEGIN_SRC emacs-lisp :tangle yes
 (use-package yaml-mode
     :mode ("\\.yml\\'"))
 #+END_SRC
*** config
**** Git config file
 #+BEGIN_SRC emacs-lisp :tangle yes
 (use-package gitignore-mode)
 #+END_SRC
*** csv

 #+BEGIN_SRC emacs-lisp :tangle yes
 (use-package csv-mode
  :custom (csv-separators '(";" ",")))
 #+END_SRC


** Budger =ledger=
*** [[https://www.youneedabudget.com/the-four-rules/][YNAB]]
    You need a budged : four simple rule to control you budged
**** Give Every Dollar a Job
     As soon as you get money, you’ll decide what it needs to do—whatever is most
     important to you. Then, instead of deciding to buy something based on your
    mood, or the big (or small?) pile of money in your checking account, you’ll
    decide based on a rock-solid plan.

     1. Get some dollars.
     2. Prioritize those dollars (give ‘em jobs!).
     3. Follow your plan.
****  Embrace Your True Expenses
     Take those large, less-frequent expenses (that usually send you into a financial
     tailspin) and break them into manageable, monthly “bills.” Good-bye, Financial
     Crisis Roller Coaster! You just won a free ticket on the Financial Peace
     Express!

     1. Find a big, infrequent expense.
     2. Create a goal to fund it monthly.
     3. When that expense arrives, just pay it!
**** Roll With The Punches
     When you overspend in a budget category, just adjust. No guilt necessary. If you
     plan to take the kids to the beach but it’s pouring down rain, do you still go?
     Of course not! Circumstances change and plans change with them. Your budget is
     no different. If you overspend in one category, free up money from another
     category and move along. Remember, you’re the boss!

     1. Choose a category with overspending.
     2. Move funds from another category to cover it.
     3. Move on with your life—no guilt!
**** Age Your Money
     With the help of the other three rules, you’ll be more purposeful about your
     spending, consistently spend less than you earn, and be more than prepared for
     the future. Eventually, you’ll be able to cover May’s rent with dollars from
     April. Your money will be at least 30 days old and you’ll wonder how you ever
     lived without the Four Rules.

     1. Be purposeful in your spending.
     2. Consistently spend less than you earn.
     3. Watch that Age of Money grow!


 #+BEGIN_QUOTE
 Ledger is a powerful, double-entry accounting system that is accessed from the
 UNIX command-line.
*** ledger capture
 [[https://github.com/ledger/ledger][John Wiegley]]
 #+END_QUOTE

 Before you can use this configuration, make sure you install =ledger= on your
 operating system.

 Now all we have to do is configure =ledger-mode=:

 #+begin_SRC emacs-lisp :tangle yes
   (use-package ledger-mode
     :mode ("\\.dat\\'" "\\.ledger\\'")
     :bind (:map ledger-mode-map ("c-x c-s" . my/ledger-save))
     :hook (ledger-mode . ledger-flymapke-enable)
     :preface
     (defun my/ledger-save ()
       "automatically clean the ledger buffer at each save."
       (interactive)
       (ledger-mode-clean-buffer)
       (save-buffer))
     :custom
     (ledger-clear-whole-transactions t)
     (ledger-reconcile-default-commodity "eur")
     (ledger-reports
      '(("account statement" "%(binary) reg --real [[ledger-mode-flags]] -f %(ledger-file) ^%(account)")
        ("balance sheet" "%(binary) --real [[ledger-mode-flags]] -f %(ledger-file) bal ^assets ^liabilities ^equity")
        ("budget" "%(binary) --empty -s -t [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:budget")
        ("budget goals" "%(binary) --empty -s -t [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:'budget goals'")
        ("budget obligations" "%(binary) --empty -s -t [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:'budget obligations'")
        ("budget debts" "%(binary) --empty -s -t [[ledger-mode-flags]] -f %(ledger-file) bal ^assets:bank ^assets:receivables ^assets:cash ^assets:'budget debts'")
        ("cleared" "%(binary) cleared [[ledger-mode-flags]] -f %(ledger-file)")
        ("equity" "%(binary) --real [[ledger-mode-flags]] -f %(ledger-file) equity")
        ("income statement" "%(binary) --invert --real -s -t [[ledger-mode-flags]] -f %(ledger-file) bal ^income ^expenses -p \"this month\""))
      (ledger-report-use-header-line nil)))

      (use-package flycheck-ledger :after ledger-mode)
 #+end_src
 *note:* by default, =ledger= uses the [[ https://xkcd.com/1179/][iso 8601]] format to write dates, which is the recommended
 format.
** Todo, agenda =org-mode=

 One of my favorite modes in GNU Emacs. I mainly use it to organize my life,
 take notes and make my presentations, but you can do lots of things with
 it. =org-mode= it's like the sky, without limits.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org
     :ensure org-plus-contrib
     :delight "Θ"
     :bind
      ("C-c l" . org-store-link)
      ("C-c a" . org-agenda)
      ("C-c c" . org-capture)
     :config
        (org-babel-do-load-languages
           'org-babel-load-languages '((calc . t)))
     :custom
        (org-use-extra-keys t)
        (org-catch-invisible-edits 'show-and-error)
        (org-cycle-separator-lines 0)
        (org-link-abbrev-alist
          '(("google-maps"      . "http://maps.google.com/maps?q=%s")
            ("open-street-map" . "http://nominatim.openstreetmap.org/search?q=%s&polygon=1")
          ))
    )
 #+END_SRC
*** generate TOC automaticaly
    If like me, you're tired of manually updating your tables of contents, =toc-org=
    will maintain a table of contents at the first heading that has a =:TOC:= tag.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package toc-org
     :after org
     :hook (org-mode . toc-org-enable))
 #+END_SRC
*** cleaner indentation
 For a cleaner online mode.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-indent :after org :ensure nil :delight)
 #+END_SRC
*** Agenda
 Nowadays, it is crucial to be organized. Even more than before. That is why it
 is important to take the time to make a configuration that is simple to use and
 that makes your life easier with an irreproachable organization.
 =org-agenda= allows me to be organized with daily tasks. As a result, I can use
 my time to the fullest.
 #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package org-agenda
         :ensure nil
         :after org
         :custom
         (org-directory "~/org")
         (org-agenda-files '("~/org/"))
         (org-agenda-dim-blocked-tasks t)
         (org-agenda-inhibit-startup t)
         (org-agenda-show-log t)
         (org-agenda-span 2)
         (org-agenda-sticky nil)
         (org-agenda-tags-column -100)
         (org-agenda-time-grid '((daily today require-timed)))
         (org-agenda-use-tag-inheritance t)
         (org-enforce-todo-dependencies t)
         (org-habit-graph-column 80)
         (org-habit-show-habits-only-for-today nil)
         (org-track-ordered-property-with-tag t)
         (org-agenda-todo-ignore-timestamp 'future)
         (org-agenda-todo-ignore-scheduled 'future)
         (org-agenda-todo-ignore-deadline  'far)
         (org-agenda-skip-scheduled-if-done t)
         (org-agenda-skip-deadline-if-done  t)
         (org-agenda-skip-scheduled-if-deadline-is-shown t)
         (org-agenda-skip-scheduled-if-done t)
         (org-agenda-skip-deadline-if-done t)
         (org-agenda-skip-deadline-prewarning-if-scheduled 'pre-scheduled)
         (org-agenda-skip-timestamp-if-done t)
         (org-agenda-skip-timestamp-if-deadline-is-shown t)
   )

#+END_SRC
**** Agenda view =org-super-agenda=
    Org super agenda allows a more readible agenda by grouping the todo item
 #+BEGIN_SRC emacs-lisp :tangle yes
       (use-package org-super-agenda
       :init
       (org-super-agenda-mode)
       :custom
       (org-agenda-custom-commands
        '(("b" "Experimental"
            ;; (org-agenda-skip-function
            ;;   '(org-agenda-skip-entry-if \\='timestamp))
            ((agenda ""
              (
              (org-agenda-span '1)
              (org-super-agenda-groups
              '(
                (:name "Agenda" :and (:time-grid t :todo t))
                (:name "Scheduled" :scheduled t)
                (:name "Deadline" :deadline t)
                (:name "Information" :and (:time-grid t :todo nil))
              ))))
             (alltodo ""
              ((org-super-agenda-groups
              '(
                (:name "Current Work"  :and(:tag "work" :todo "INPROGRESS"))
                (:name "recurrent Work":and(:tag "work" :tag "recurrent"))
                (:name "Next work"
                 :and(:tag "work" :todo "TODO"))
                (:name "on pause Work" :todo "WAITING")
                (:name "recurrent"      :tag "recurrent")
                (:name "Current"        :todo "INPROGRESS")
                (:name "Reserve ASAP"   :todo "RESERVE")
                (:name "Next "          :todo "TODO")
                (:name "Daily"
                 :and(:todo ("TOBUY" "FETCH")
                     :tag  "daily"))
                (:name "FETCH ASAP"       :todo ("TOBUY" "FETCH"))
                (:name "One day"        :todo "SOMEDAY")
                (:name "on pause"       :todo "WAITING")
                (:discard (:todo ("TOGO" "GO"  "TOUSE" "USE" "IDEA")))
              ))))
             ))))
   )
#+END_SRC
**** Agenda view "square view"  =calfw=

 #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package calfw :after org-agenda)

      (use-package calfw-org
         :after calfw
         :bind ("C-c z" . cfw:open-org-calendar)
         :custom
         (cfw:org-overwrite-default-keybinding t))

 #+END_SRC

*** Bullets
 Prettier [[https://github.com/sabof/org-bullets][bullets]] in org-mode.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-bullets
     :hook (org-mode . org-bullets-mode)
     :custom (org-bullets-bullet-list '("●" "▲" "■" "✶" "◉" "○" "○")))
 #+END_SRC

*** Capture
 =org-capture= templates saves you a lot of time when adding new entries. I use
 it to quickly record tasks, ledger entries, notes and other semi-structured
 information.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-capture
    :ensure nil
    :after org
    :preface
  (defun my/org-timestamp-add-reminder (date day)
    "add a reminder to a timestamp like : <2019-11-14 -5d>"
    (format "%s -%dd%s"  (substring date 0 -1) day (substring date -1)))

  (defvar my/org-toreserve-template
"* RESERVE %^{Name} [[google-maps:%\\2][@dress]] %^g
  :PROPERTIES:
  :Created:     %U
  :Name:   %\\1
  :Type:   %^{Type}p
  :Place:  %^{Place}
  :With:   %^{With}
  :GMap:   [[google-maps:%\\2][@dress]]
  :END:
  %^{When}T
")

  (defvar my/org-togo-template
"* GO %^{Name} [[:%\\2][@dress]] %^g
  :PROPERTIES:
  :Created:     %U
  :Name:   %\\1
  :Type:   %^{Type}p
  :Place:  %^{Place}
  :With:   %^{With}
  :GMap:   [[google-maps:%\\2][@dress]]
  :END:
  %^{When}T
")


  (defvar my/org-trip-template
"* GO %\\1 -%\\3-> %\\2
  :PROPERTIES:
  :Created: %U
  :From:    %^{From|Lyon Part-dieu|Lyon Perrache|Lyon Georges|Paris GdL|Montpellier St-Roch}
  :To:    %^{To|Lyon Part-dieu|Lyon Perrache|Lyon Georges|Paris GdL|Montpellier St-Roch}
  :Type:    %^{Type}p
  :With:    %^{With}
  :END:
  %^{When}T
")

  (defvar my/org-roundtrip-template
"* GO %\\1 -%\\3-> %\\2
  :PROPERTIES:
  :Created: %U
  :From:    %^{From|Lyon Part-dieu|Lyon Perrache|Lyon Georges|Paris GdL|Montpellier St-Roch}
  :To:    %^{to|Lyon Part-dieu|Lyon Perrache|Lyon Georges|Paris GdL|Montpellier St-Roch}
  :Type:    %^{Type}p
  :With:    %^{With}
  :END:
  %^{When}T\n* GO %\\2 -> %\\1
  :PROPERTIES:
  :Created: %U
  :From:      %\\2
  :To:       %\\1
  :Type:    %^{Type}p
  :With:    %^{With}
  :END:
  %^{When}T
")

  (defvar my/org-voucher-template
"* USE %^{Valor}
   DEADLINE:%^{Before}t
  :PROPERTIES:
  :Reduction:     %^{Reduction}
  :At:     %^{At|oui.sncf|ouibus|ouigo...}
  :END:
  %^{Cuando}t
")

  (defvar my/org-todo-template
"* TODO %^{What} %^g
  :PROPERTIES:
  :Created:     %U
  :END:
")

  (defvar my/org-someday-template
"* SOMEDAY %^{What} %^g
  :PROPERTIES:
  :Created:     %U
  :END:
")

(defvar my/org-work-move-template
"* TODO %^{What} %^g
  :PROPERTIES:
  :Created:     %U
  :mission:     %^{mission}p
  :CATEGORY:    %\\2
  :END:
")

  (defvar my/org-stuff-buy-template
"* FETCH %^{What}
  :PROPERTIES:
  :Created:     %U
  :END:
")

  (defvar my/org-stuff-gift-template
"* IDEA %^{What}
  :PROPERTIES:
  :Created:     %U
  :For: %^{For}
  :When: %^{When}t
  :END:
")

  (defvar my/org-stuff-flat-template
"* BUY %^{What}
  :PROPERTIES:
  :Created:     %U
  :Room: %^{Room}p
  :CATEGORY: %\\2
  :END:
")

  :custom
  (org-capture-templates
   `(("e" "Event")
      ("es" "Show")
        ("esr" "To reserve" entry (file+headline "~/org/master.org" "Show"),
          my/org-toreserve-template)
        ("esg" "To go" entry (file+headline "~/org/master.org" "Show"),
          my/org-togo-template)
      ("er" "To reserve" entry (file+headline "~/org/master.org" "Agenda"),
        my/org-toreserve-template)
      ("eg" "To go" entry (file+headline "~/org/master.org" "Agenda"),
        my/org-togo-template)
      ("et" "Trip")
      ("ets" "Single trip" entry (file+headline "~/org/master.org" "Trip"),
        my/org-trip-template)
      ("etr" "Round trip" entry (file+headline "~/org/master.org" "Trip"),
        my/org-roundtrip-template)
     ("t" "TO-DO")
      ("tt" "todo" entry (file+headline "~/org/master.org" "TO-DO"),
        my/org-todo-template)
      ("to" "oneday" entry (file+headline "~/org/master.org" "TO-DO"),
        my/org-someday-template)
      ("tw" "work" entry (file+headline "~/org/master.org" "Work"),
        my/org-work-move-template)
     ("v" "voucher" entry (file+headline "~/org/master.org" "Voucher"),
        my/org-voucher-template)
     ("s" "stuff")
      ("sb" "buy" entry (file+headline "~/org/master.org" "objet"),
        my/org-stuff-buy-template)
      ("sg" "gift" entry (file+headline "~/org/master.org" "objet"),
        my/org-stuff-gift-template)
      ("sa" "Flat" entry (file+headline "~/org/master.org" "Flat"),
        my/org-stuff-flat-template)

)))
#+END_SRC

*** COMMENT Clock

 # # Being organized is one thing, but being optimal is another. =org-clock= allows
 # # you to estimate your tasks and time them. This is useful, since with experience,
 # # you can have a better estimate of the time that needs to be given to each task.

 # # #+BEGIN_SRC emacs-lisp :tangle yes
 # #   (use-package org-clock
 # #     :ensure nil
 # #     :after org
 # #     :preface
 # #     (defun my/org-mode-ask-effort ()
 # #       "Ask for an effort estimate when clocking in."
 # #       (unless (org-entry-get (point) "Effort")
 # #         (let ((effort
 # #                (completing-read
 # #                 "Effort: "
 # #                 (org-entry-get-multivalued-property (point) "Effort"))))
 # #           (unless (equal effort "")
 # #             (org-set-property "Effort" effort)))))
 # #     :hook (org-clock-in-prepare-hook . my/org-mode-ask-effort)
 # #     :custom
 # #     (org-clock-clocktable-default-properties
 # #      '(:block day :maxlevel 2 :scope agenda :link t :compact t :formula %
 # #               :step day :fileskip0 t :stepskip0 t :narrow 80
 # #               :properties ("Effort" "CLOCKSUM" "CLOCKSUM_T" "TODO")))
 # #     (org-clock-continuously nil)
 # #     (org-clock-in-switch-to-state "STARTED")
 # #     (org-clock-out-remove-zero-time-clocks t)
 # #     (org-clock-persist t)
 # #     (org-clock-persist-file (expand-file-name (format "%s/emacs/org-clock-save.el" xdg-cache)))
 # #     (org-clock-persist-query-resume nil)
 # #     (org-clock-report-include-clocking-task t)
 # #     (org-show-notification-handler (lambda (msg) (alert msg))))
 # # #+END_SRC

*** Contacts
    The best solution to maintain your contacts. I tend to use =org-contacts= to
    remember their birthdays so I can be the first to wish them that. Be careful
    that to install it, this one is available with =org-plus-contrib=.
 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-contacts
     :ensure nil
     :after org
     :custom (org-contacts-files '("~/org/contacts.org")))
 #+END_SRC

*** Customization
 Let's change the foreground and the weight of each keywords.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package org-faces
     :ensure nil
     :after org
     :custom
     (org-todo-keyword-faces
      '(
          ("RESERVE"  . (:foreground "red" :weight bold))
          ("GO"       . (:foreground "orange" :weight bold))

          ("WENT"       . (:foreground "green" :weight bold))
          ("CANCELED"   . (:foreground "grey"))


          ("SOMEDAY"    . (:foreground "blue"))
          ("TODO"       . (:foreground "red" :weight bold))
          ("INPROGRESS" . (:foreground "orange" :weight bold))
          ("WAITING"    . (:foreground "yellow" :weight bold))

          ("DONE"       . (:foreground "green"))
          ("ABORDED"    . (:foreground "grey" ))


          ("IDEA"       . (:foreground "blue" :weight bold))
          ("FETCH"      . (:foreground "red" :weight bold))
          ("GIVE"     . (:foreground "orange" :weight bold))

          ("FETCHED"     . (:foreground "green" :weight bold))
          ("GIVEN"      . (:foreground "green" :weight bold))

          ("USE"      . (:foreground "red" :weight bold))
          ("CONSUMED" . (:foreground "green" :weight bold))
          ("LOST" . (:foreground "grey"))
        )))
 #+END_SRC

*** syncronize
**** calendar =org-caldav=
 #+BEGIN_SRC emacs-lisp :tangle yes
      (use-package org-caldav
        :init
        (defvar org-caldav-sync-timer nil
                "Timer that `org-caldav-push-timer' used to reschedule itself, or nil.")
        (defun org-caldav-sync-with-delay (secs)
          (when org-caldav-sync-timer (cancel-timer org-caldav-sync-timer))
          (setq org-caldav-sync-timer
                (run-with-idle-timer (* 1 secs) nil 'org-caldav-sync)))
        (setq org-caldav-url
              "https://cloud.frontir.cc/remote.php/dav/calendars/sylvainr/")
        (setq org-caldav-calendar-id "personal")
        (setq org-caldav-inbox "~/org/sync2.org")
        (setq org-caldav-files
              '("~/org/master.org" "~/org/diario.org" "~/org/agenda.org" "~/org/todo.org" "~/org/work.org"))
        :config
        (setq org-icalendar-alarm-time 1)
        (setq org-caldav-show-sync-results nil)
        (setq org-icalendar-include-todo t)
        (setq org-icalendar-use-deadline  '(event-if-todo event-if-not-todo todo-due))
        (setq org-icalendar-use-scheduled '(todo-start event-if-todo event-if-not-todo))
        :hook (
        (kill-emacs . org-caldav-sync)
               (after-save .
                   (lambda ()
                   (when (eq major-mode 'org-mode) (org-caldav-sync-with-delay 30)))))
   )
 #+END_SRC

*** Journal

 Recently, I started writing a journal about my daily life as I read that
 journals improve mental claritym, help solve problems, improve overall focus,
 insight and understanding, track the overall development and facilitate personal
 growth.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package org-journal
    :after org
    ;; :bind (:map (org-journal-map))
    :bind (("C-c C-f" . org-journal-open-next-entry)
           ("C-c C-b" . org-journal-open-previous-entry)
           ("C-c C-j" . org-journal-new-entry)
           ("C-c C-s" . org-journal-search)
           ("C-c t" . org-journal-new-entry))
    :custom
    (org-journal-dir "~/org/journal/")
    (org-journal-file-format "%Y%m%d")
    (org-journal-enable-agenda-integration t))
#+END_SRC

*** Languages

 With that, I can compile many languages with =org-mode=.

 #+BEGIN_SRC emacs-lisp :tangle yes
   (use-package ob-C :ensure nil :after org)
   ;; (use-package ob-css :ensure nil :after org)
   ;; (use-package ob-ditaa :ensure nil :after org)
   ;; (use-package ob-dot :ensure nil :after org)
   (use-package ob-emacs-lisp :ensure nil :after org)
   ;; (use-package ob-gnuplot :ensure nil :after org)
   (use-package ob-java :ensure nil :after org)
   (use-package ob-js :ensure nil :after org)
   (use-package ob-latex :ensure nil :after org)
   (use-package ob-ledger :ensure nil :after org)
   (use-package ob-makefile :ensure nil :after org)
   (use-package ob-org :ensure nil :after org)

   ;; (use-package ob-plantuml
   ;;   :ensure nil
   ;;   :after org
   ;;   :custom (org-plantuml-jar-path (expand-file-name (format "%s/plantuml.jar" xdg-lib))))

   ;; (use-package ob-python :ensure nil :after org)
   ;; (use-package ob-ruby :ensure nil :after org)
   (use-package ob-shell :ensure nil :after org)
   (use-package ob-sql :ensure nil :after org)
 #+END_SRC

*** Other improvement
 #+BEGIN_SRC emacs-lisp :tangle yes
 (defun org-convert-csv-table (beg end)
 (interactive (list (mark) (point)))
 (org-table-convert-region beg end ";")
  )

 #+END_SRC

*** External call
 #+BEGIN_SRC emacs-lisp :tangle yes

 #+END_SRC
** Mail =gnus=
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package gnus
      :bind (("C-x e" . gnus)
            :map gnus-group-mode-map
            ("C-c C-f" . gnus-summary-mail-forward))
      :custom
      (gnus-fetch-old-headers t))
    (use-package w3m
      :after gnus)
#+END_SRC

** Contact =bbdb=

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package bbdb
    :after gnus
    :config (setq bbdb-file "~/Document/contact.el" ))
  ;; (use-package bbdb-vcard
  ;;   :after bbdb)
  ;; (use-package vdirel
  ;;   :custom
  ;;   (vdirel-repository ~/Contacts))
#+END_SRC

** Git
*** Git =magit=

It is quite common to work on Git repositories, so it is important to have a
configuration that we like.

#+BEGIN_QUOTE
[[https://github.com/magit/magit][Magit]] is an interface to the version control system Git, implemented as an Emacs
package. Magit aspires to be a complete Git porcelain. While we cannot (yet)
claim that Magit wraps and improves upon each and every Git command, it is
complete enough to allow even experienced Git users to perform almost all of
their daily version control tasks directly from within Emacs. While many fine
Git clients exist, only Magit and Git itself deserve to be called porcelains.

[[https://github.com/tarsius][Jonas Bernoulli]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package magit
     :bind ("C-x g" . magit-status)
  )
  (use-package git-commit
    :after magit
    :hook (git-commit-mode . my/git-commit-auto-fill-everywhere)
    :custom (git-commit-summary-max-length 80)
    :preface
    (defun my/git-commit-auto-fill-everywhere ()
      "Ensures that the commit body does not exceed 72 characters."
      (setq fill-column 72)
      (setq-local comment-auto-fill-only-comments nil)))
#+END_SRC

In addition to that, I like to see the lines that are being modified in the file
while it is being edited.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-gutter
    :delight
    :init (global-git-gutter-mode +1))
#+END_SRC

Finally, one last package that I like to use with Git to easily see the changes
made by previous commits.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package git-timemachine :delight)
#+END_SRC
*** COMMENT Gitlab =gitlab=
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package gitlab
  ;; :delight
  ;; :init
  ;; (setq gitlab-host "http://cosmos.movesol.fr/gitlab/"
  ;;       gitlab-token-id "ucc1ZKcKGW_1_cEBPz8J"))

  ;; (use-package helm-gitlab :delight
  ;; :after '(helm gitlab))
#+END_SRC
*** Git forges =forge=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package forge
  :after magit
  :delight
  :config
  (add-to-list 'forge-alist '("cosmos.movesol.fr:2222"  "cosmos.movesol.fr/gitlab/api/v4" "cosmos.movesol.fr/gitlab/" forge-gitlab-repository)))
#+END_SRC


** File Explorer =dired=
   Dired is a major mode for exploring file
   dired-x is a minor that brings a lot to dired like hidding
   - uninteresting file
   - guessing which command to call...

   dired-du give the size of directory using du or lisp
   dired-du should be customize more than that

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dired
    :delight "Dired "
    :ensure nil
    :custom
    (dired-auto-revert-buffer t)
    (dired-dwim-target t)
    (dired-hide-details-hide-symlink-targets nil)
    (dired-omit-files "^\\...+$")
    (dired-omit-mode t)
    (dired-listing-switches "-alh")
    (dired-ls-F-marks-symlinks nil)
    (dired-recursive-copies 'always))

  (use-package dired-du
   :after dired)
  (use-package dired-x
  :ensure nil
  :after dired)



#+END_SRC
** password-store =pass=
   Pass helps me to be a bit more secure on my password management
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package pass
    :delight "Pass ")
#+END_SRC
** Game
**** =Typing=
     A game for fast typers
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package typing
  :defer t)
#+END_SRC
** Typing training
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package typing-practice
  :defer t)
#+END_SRC
** Shell =eshell=
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package eshell
     :bind (("C-x t" . eshell)
           ;; (:map eshell-mode-map
           ;;  ("<tab>" . completion-at-point))
           )
     :init
      (setq ;; eshell-buffer-shorthand t ...  Can't see Bug#19391
            eshell-scroll-to-bottom-on-input 'all
            eshell-error-if-no-glob t
            eshell-hist-ignoredups t
            eshell-save-history-on-exit t
            eshell-prefer-lisp-functions nil
            eshell-destroy-buffer-when-process-dies t)
  )
#+END_SRC
** social acount
*** twitter =twittering=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package twittering-mode
  :init
   (set-face-attribute 'twittering-username-face nil
                                :underline nil
                                :weight 'bold
                                :foreground "darksalmon")
  :config
   (twittering-use-master-password t)
   (twittering-timer-interval 300)
   (twittering-url-show-status nil)
   (twittering-icon-mode nil)
   (twittering-status-format "%i %s\n%FILL[ ]{%T}\n %FACE[glyphless-char]{%@ from %f%L%r%R}\n")
  :hook ('twittering-edit-mode .
        (lambda () (auto-fill-mode -1) (visual-line-mode)))
  )

(twittering-enable-unread-status-notifier)

(add-hook 'twittering-mode-hook
          (lambda ()
            (setq twittering-timer-interval 300)
            (setq twittering-url-show-status nil)
            (setq twittering-icon-mode nil)
            (setq twittering-status-format "%i %s\n%FILL[ ]{%T}\n %FACE[glyphless-char]{%@ from %f%L%r%R}\n")
            (set-face-attribute 'twittering-username-face nil
                                :underline nil
                                :weight 'bold
                                :foreground "darksalmon")))


#+END_SRC
* Minor mode
** Auto-Completion =company=

=company= provides auto-completion at point and to Displays a small pop-in
containing the candidates.

#+BEGIN_QUOTE
Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

[[http://company-mode.github.io/][Dmitry Gutov]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package company
    :defer 0.5
    :delight
    :custom
     (company-begin-commands '(self-insert-command))
     (company-idle-delay 0.2)
     (company-minimum-prefix-length 2)
     (company-show-numbers t)
     (company-tooltip-align-annotations 't)
     (global-company-mode t))

    ;; (use-package helm-company
    ;;  :after helm company
    ;;  :delight
    ;;  :bind ((:map company-mode-map   ("C-:" .  helm-company))
    ;;         (:map company-active-map ("C-:" .  helm-company))))
#+END_SRC

# I use =company= with =company-box= that allows a company front-end with icons.

#+BEGIN_SRC emacs-lisp :tangle yes
   (use-package company-box
     :after company
     :delight
     :hook (company-mode . company-box-mode))
#+END_SRC

** Internet interface
#+BEGIN_SRC emacs-lisp :tangle yes
  (setq browse-url-browser-function 'browse-url-firefox)
#+END_SRC
*** Search wikipage =wiki-summary=

It is impossible to know everything, which is why a quick description
of a term, without breaking its workflow, is ideal.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package wiki-summary
    :defer 1
    :bind ("C-c W" . wiki-summary)
    :preface
    (defun my/format-summary-in-buffer (summary)
      "Given a summary, stick it in the *wiki-summary* buffer and display the buffer"
      (let ((buf (generate-new-buffer "*wiki-summary*")))
        (with-current-buffer buf
          (princ summary buf)
          (fill-paragraph)
          (goto-char (point-min))
          (text-mode)
          (view-mode))
        (pop-to-buffer buf))))

  (advice-add 'wiki-summary/format-summary-in-buffer :override #'my/format-summary-in-buffer)
#+END_SRC

*** =engine-mode=
	With it I can start a search from within emacs.
	I use duckduckgo and bang

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package engine-mode
    :config
    (engine-mode t)
    (defengine duckduckgo
      "https://duckduckgo.com/?q=%s"
      :keybinding "d"))

#+END_SRC

** TODO Dashboard
Always good to have a dashboard.
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package dashboard
    :preface
       :hook ('after-make-frame-functions .
              (lambda (frame)
                 (when (eq (length (frame-list)) 2)
                    (progn
                    (select-frame frame)
                    (dashboard-refresh-buffer)))))
    :custom (dashboard-startup-banner 'logo)
    :config (dashboard-setup-startup-hook))
#+END_SRC
** TODO reset config when config.org changes

not-sur to understand how it works
I'm using an =.org= file to maintain my GNU Emacs configuration. However, at his
launch, it will loads the =config.el= source file for a faster loading.

The code below, executes =org-babel-tangle= asynchronously when
=config.org= is saved.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package async)

  (defvar *config-file* ".emacs.d/config.org" "The configuration file.")

  (defvar *config-last-change* (nth 5 (file-attributes *config-file*))
    "Last modification time of the configuration file.")

  (defvar *show-async-tangle-results* nil "Keeps *emacs* async buffers around for later inspection.")

  (defun my/config-updated ()
    "Checks if the configuration file has been updated since the last time."
    (time-less-p *config-last-change*
                 (nth 5 (file-attributes *config-file*))))

  (defun my/config-tangle ()
    "Tangles the org file asynchronously."
    (when (my/config-updated)
      (setq *config-last-change*
            (nth 5 (file-attributes *config-file*)))
      (my/async-babel-tangle *config-file*)))

  (defun my/async-babel-tangle (org-file)
    "Tangles the org file asynchronously."
    (let ((init-tangle-start-time (current-time))
          (file (buffer-file-name))
          (async-quiet-switch "-q"))
      (async-start
       `(lambda ()
          (require 'org)
          (org-babel-tangle-file ,org-file))
       (unless *show-async-tangle-results*
         `(lambda (result)
            (if result
                (message "SUCCESS: %s successfully tangled (%.2fs)."
                         ,org-file
                         (float-time (time-subtract (current-time)
                                                    ',init-tangle-start-time)))
              (message "ERROR: %s as tangle failed." ,org-file)))))))
#+END_SRC

** COMMENT Spelling  =flyspell=

For the other words that would not be in my list of abbreviations, =flyspell=
enables spell checking on-the-fly in GNU Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package flyspell
  ;;   :defer 1
  ;;   :delight
  ;;   :custom
  ;;   (flyspell-abbrev-p t)
  ;;   (flyspell-issue-message-flag nil)
  ;;   (flyspell-issue-welcome-flag nil)
  ;;   (flyspell-mode 1))

    ;; (use-package flyspell-correct-ivy
    ;;   :bind ("C-M-;" . flyspell-correct-wrapper)
    ;;   :init
    ;;     (setq flyspell-correct-interface #'flyspell-correct-ivy))
  ;; (use-package ispell
  ;;   :custom
  ;;   (ispell-silently-savep t))
#+END_SRC

** History =savehist=

Provides the ability to have commands and their history saved so that whenever
you return to work, you can re-run things as you need them. This is not a
radical function, it is part of a good user experience.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package savehist
    :custom
    (history-delete-duplicates t)
    (history-length t)
    (savehist-additional-variables
      '(kill-ring search-ring regexp-search-ring))
    (savehist-file  "~/.emacs.d/history" )
    (savehist-save-minibuffer-history 1)
    :config (savehist-mode))
#+END_SRC

** improved package menu =paradox=

Improved GNU Emacs standard package menu.

#+BEGIN_QUOTE
Project for modernizing Emacs' Package Menu. With improved appearance, mode-line
information. Github integration, customizability, asynchronous upgrading, and
more.

[[https://github.com/Malabarba/paradox][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package paradox
    :defer 1
    :custom
    (paradox-column-width-package 27)
    (paradox-column-width-version 13)
    (paradox-execute-asynchronously t)
    (paradox-hide-wiki-packages t)
    :config
    (paradox-enable)
    (remove-hook 'paradox-after-execute-functions #'paradox--report-buffer-print))
#+END_SRC

** Text formatting
*** force Auto-indent =aggressive-indent=

Auto-indent code as you write.

#+BEGIN_QUOTE
=electric-indent-mode= is enough to keep your code nicely aligned when all you
do is type. However, once you start shifting blocks around, transposing lines,
or slurping and barfing sexps, indentation is bound to go wrong.

=aggressive-indent-mode= is a minor mode that keeps your code *always* indented.
It reindents after every change, making it more reliable than
electric-indent-mode.

[[https://github.com/Malabarba/aggressive-indent-mode][Artur Malabarba]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package aggressive-indent
    :defer 2
    :hook ((css-mode . aggressive-indent-mode)
           (emacs-lisp-mode . aggressive-indent-mode)
           (js-mode . aggressive-indent-mode)
           (lisp-mode . aggressive-indent-mode))
    :custom (aggressive-indent-comments-too))
#+END_SRC

*** colorize color text =rainbow-mode=

Colorize colors as text with their value.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-mode
    :delight
    :custom
    (rainbow-x-colors t)
    (rainbow-r-colors t)
    :config(rainbow-mode))
#+END_SRC

*** Whitespace =whitespace=

It is often annoying to see unnecessary blank spaces at the end of a line or file.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package whitespace
    :defer 1
    :hook (before-save . delete-trailing-whitespace))
#+END_SRC

** Text editing
*** edit all occurence =iedit=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package iedit
  :bind ("C-c e" . iedit-mode))
#+END_SRC
*** delete til next char =hungry-delete=
*** move text =move-text=

 Moves the current line (or if marked, the current region's, whole lines).

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package move-text
    :defer 2
    :bind (("M-p" . move-text-up)
           ("M-n" . move-text-down))
    :config (move-text-default-bindings))
#+END_SRC


#+BEGIN_QUOTE
Deleting a whitespace character will delete all whitespace until the next
non-whitespace character.

# [[https://github.com/nflath/hungry-delete][Nathaniel Flath]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package hungry-delete
    :defer 0.7
    :delight
    :config (global-hungry-delete-mode))
#+END_SRC

** COMMENT Undo-redo =undo-tree=

GNU Emacs's undo system allows you to recover any past state of a buffer. To do
this, Emacs treats "undo itself as another editing that can be undone".

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package undo-tree
  ;;   :delight
  ;;   :bind ("C--" . undo-tree-redo)
  ;;   :init (global-undo-tree-mode)
  ;;   :custom
  ;;   (undo-tree-visualizer-timestamps t)
  ;;   (undo-tree-visualizer-diff t))
#+END_SRC

** keystroke =which-key=

It's difficult to remember all the keyboard shortcuts. The =which-key= package
helps to solve this.

I used =guide-key= in my past days, but =which-key= is a good replacement.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package which-key
    :defer 0.2
    :delight
    :config (which-key-mode))
#+END_SRC
** COMMENT autocompletion interface =Helm=

Helm is more powerful than ivy and as my computer as speed to spare.
not a big fan in the end.
I prefere the integration of ivy
#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package helm
  ;;   :delight
  ;;   :config (helm-mode)
  ;;   :bind (
  ;;        ("C-x C-f" . helm-find-files)
  ;;        ("M-y"     . helm-show-kill-ring)
  ;;        ("C-x b"   . helm-buffers-list)
  ;;        ))
  ;;  (use-package helm-smex
  ;;    :after helm
  ;;    :bind ("M-x" . helm-smex)
  ;;          ("M-X" . helm-smex-major-mode-commands))

  ;;  (use-package helm-descbinds
  ;;    :after helm
  ;;    :bind ("C-h b" . helm-descbinds))

  ;;  (use-package helm-projectile
  ;;    :after helm projectile
  ;;    :config (helm-projectile-on))

  ;;  (use-package helm-swoop
  ;;    :after helm
  ;;    :bind (("M-i" . helm-swoop)
  ;;           ("C-s" . helm-swoop)
  ;;           ("C-r" . helm-swoop)
  ;;           ("M-I" . helm-swoop-back-to-last-point)
  ;;           ("C-c M-i" . helm-multi-swoop)
  ;;           ("C-x M-i" . helm-multi-swoop-all)
  ;;           (:map helm-swoop-map
  ;;               (("C-r" . helm-previous-line)
  ;;                ("C-s" . helm-next-line)
  ;;                ("M-m" . helm-multi-swoop-current-mode-from-helm-swoop)))
  ;;           (:map helm-multi-swoop-map
  ;;                ("C-r" . helm-previous-line)
  ;;                ("C-s" . helm-next-line))
  ;;           )
  ;;    :custom
  ;;    (helm-swoop-speed-or-color t)
  ;;    (helm-swoop-move-to-line-cycle t)
  ;;    (helm-swoop-use-line-number-face t) ;; Optional face for line numbers
  ;;    )
#+END_SRC
*** COMMENT =helm-org-rifle=
** autocompletion =Ivy=

I used =helm= before, but I find =ivy= faster and lighter.

#+BEGIN_QUOTE
Ivy is a generic completion mechanism for Emacs. While it operates similarly to
other completion schemes such as icomplete-mode, Ivy aims to be more efficient,
smaller, simpler, and smoother to use yet highly customizable.

[[https://github.com/abo-abo/ivy][Oleh Krehel]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package counsel
    :after ivy smex
    :delight
    :bind ("M-x" . counsel-M-x)
    :config (counsel-mode 1))

  (use-package ivy
    :delight
    :bind (("C-c C-r" . ivy-resume)
           ("C-x B" . ivy-switch-buffer-other-window))
    :custom
    (ivy-count-format "(%d/%d) ")
    (ivy-use-virtual-buffers t)
    (ivy-extra-directories nil)
    :config (ivy-mode))

  (use-package ivy-pass
    :after ivy
    :commands ivy-pass)

  (use-package ivy-rich
    :after ivy
    :init (setq ivy-rich-parse-remote-file-path t)
    :config (ivy-rich-mode 1))

  (use-package swiper
    :after ivy
    :bind (("C-s" . swiper)
           ("C-r" . swiper)))
#+END_SRC

** M-x enhancement =smex=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package smex)
#+END_SRC
** Text Navigation
*** goto beginning of line
This function is a mix of =C-a= and =M-m=.

From: http://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/

#+BEGIN_SRC emacs-lisp :tangle yes
  (defun my/smarter-move-beginning-of-line (arg)
  "Moves point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))

(global-set-key [remap org-beginning-of-line] #'my/smarter-move-beginning-of-line)
(global-set-key [remap move-beginning-of-line] #'my/smarter-move-beginning-of-line)
#+END_SRC


** Point and Region

Increase region by semantic units. It tries to be smart about it and adapt to
the structure of the current major mode.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package expand-region
    :defer 2
    :bind (("C-+" . er/contract-region)
           ("C-=" . er/expand-region)))
#+END_SRC

I find useful to delete a line and a region with only =C-w=.

#+BEGIN_SRC emacs-lisp :tangle yes
  (defadvice kill-region (before slick-cut activate compile)
    "When called interactively with no active region, kill a single line instead."
    (interactive
     (if mark-active (list (region-beginning) (region-end))
       (list (line-beginning-position)
             (line-beginning-position 2)))))
#+END_SRC

** Recent Files

Provides fast access to the recent files.

#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package recentf
      ;; :bind ("C-x r" . helm-recentf)
      :bind (("C-x r" . counsel-recentf)
             ;; ("C-x b" . counsel-ibuffer)
  )

      :after counsel
      :init (recentf-mode)
      :custom
      (recentf-exclude (list "COMMIT_EDITMSG"
                             "~$"
                             "/scp:"
                             "/ssh:"
                             "/sudo:"
                             "/tmp/"
                             "recentf"
                             ".newsrc-dribble"
                             ))
      (recentf-max-menu-items 15)
      (recentf-max-saved-items 200)
      (recentf-save-file "~/.emacs.d/recentf" )
      :config (run-at-time nil (* 5 60) 'recentf-save-list))
#+END_SRC

** Buffer and Windows
   Don't ask before killing a buffer. I know what I'm doing.
   #+BEGIN_SRC emacs-lisp :tangle yes
  (global-set-key [remap kill-buffer] #'kill-current-buffer)
   #+END_SRC
*** Revert buffer to saved file =autorevert=

Avoids call the function or reload Emacs.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package autorevert
    :ensure nil
    :delight auto-revert-mode
    :bind ("C-x R" . revert-buffer)
    :custom (auto-revert-verbose nil)
    :config (global-auto-revert-mode 1))
#+END_SRC

#+RESULTS:
: revert-buffer

*** Parenthesis =rainbow-delimiters=

#+BEGIN_QUOTE
rainbow-delimiters is a "rainbow parentheses"-like mode which highlights
delimiters such as parentheses, brackets or braces according to their
depth. Each successive level is highlighted in a different color. This makes it
easy to spot matching delimiters, orient yourself in the code, and tell which
statements are at a given depth.

[[https://github.com/Fanael/rainbow-delimiters][Fanael Linithien]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package rainbow-delimiters
    :defer 1
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC
*** move around buffers =ace-window=
  ace window allow to simply switch when only 2 buffer or to choose
  which buffer with key when multiple buff

  ibuffer is a better buffer mode

  toggle-window-split : switch layout when two buffers are open
#+BEGIN_SRC emacs-lisp :tangle yes
    (use-package ace-window
      :bind
      (("C-x o" . ace-window)
       ("M-o" . ace-window))
      :init
      (setq aw-keys '(?q ?s ?d ?f ?g ?h ?j ?k ?l))
      (setq aw-scope 'frame)
    )

    (use-package ibuffer
     :bind ("C-x C-b" . ibuffer)
     :custom
        (ibuffer-saved-filter-groups
        '(("default"
               ("dired" (mode . dired-mode))
               ("org"   (name . "^.*org$"))
               ("magit" (or (mode . magit-mode)
                            (name . "^magit.*$" )))

               ("IRC"   (or (mode . circe-channel-mode) (mode . circe-server-mode)))
               ("web"   (or (mode . web-mode) (mode . js2-mode)))
               ("shell" (or (mode . eshell-mode) (mode . shell-mode)))
               ("gnus"  (or (mode . message-mode)
                            (mode . bbdb-mode)
                            (mode . mail-mode)
                            (mode . gnus-group-mode)
                            (mode . gnus-summary-mode)
                            (mode . gnus-article-mode)
                            (name . "^\\.bbdb$")
                            (name . "^\\.newsrc-dribble")))
               ("programming" (or
                               (mode . java-mode)
                               (mode . groovy-mode)
                               (mode . conf-space-mode)))
               ("emacs" (or
                         (name . "^\\*scratch\\*$")
                         (name . "^\\*Messages\\*$")))
               ("Ediff" (name . "^\\*Ediff.*\\*$"))
               )))
          :hook ('ibuffer-mode .
          (lambda ()
            (ibuffer-auto-mode 1)
            (ibuffer-switch-to-saved-filter-groups "default"))))

  (defun toggle-window-split ()
    (interactive)
      (if (= (count-windows) 2)
        (let* ((this-win-buffer (window-buffer))
               (next-win-buffer (window-buffer (next-window)))
               (this-win-edges (window-edges (selected-window)))
               (next-win-edges (window-edges (next-window)))
               (this-win-2nd (not (and (<= (car this-win-edges)
                                           (car next-win-edges))
                                       (<= (cadr this-win-edges)
                                           (cadr next-win-edges)))))
               (splitter
                (if (= (car this-win-edges)
                       (car (window-edges (next-window))))
                    'split-window-horizontally
                  'split-window-vertically)))
          (delete-other-windows)
          (let ((first-win (selected-window)))
            (funcall splitter)
            (if this-win-2nd (other-window 1))
            (set-window-buffer (selected-window) this-win-buffer)
            (set-window-buffer (next-window) next-win-buffer)
            (select-window first-win)
            (if this-win-2nd (other-window 1))))))

    (global-set-key (kbd "C-x |") 'toggle-window-split)
#+END_SRC

*** =winner=

I often undo's and redo's with window configurations.

#+BEGIN_QUOTE
Winner mode is a global minor mode that records the changes in the window
configuration (i.e. how the frames are partitioned into windows) so that the
changes can be "undone" using the command =winner-undo=. By default this one is
bound to the key sequence ctrl-c left. If you change your mind (while undoing),
you can press ctrl-c right (calling =winner-redo=).

[[https://github.com/emacs-mirror/emacs/blob/master/lisp/winner.el][Ivar Rummelhoff]]
#+END_QUOTE

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package winner
    :defer 2
    :config (winner-mode 1))
#+END_SRC

** Word Wrap =simple=

I like to have lines of the same length.

#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package simple
    :ensure nil
    :delight (auto-fill-function)
    :bind ("C-x p" . pop-to-mark-command)
    :hook ((prog-mode . turn-on-auto-fill)
           (text-mode . turn-on-auto-fill))
    :custom (set-mark-command-repeat-pop t))
#+END_SRC


** custom fonction
#+BEGIN_SRC emacs-lisp :tangle yes
;; revert all open file buffer
(defun revert-all-buffers ()
  "Refreshes all open buffers from their respective files."
  (interactive)
  (dolist (buf (buffer-list))
    (with-current-buffer buf
      (when (and (buffer-file-name) (file-exists-p (buffer-file-name)) (not (buffer-modified-p)))
        (revert-buffer t t t) )))
  (message "Refreshed open files.") )

;; reload emacs config
(defun reload-dotemacs-file ()
  "reload your .emacs file without restarting Emacs"
  (interactive)
  (load-file "~/.emacs.d/init.el"))

#+END_SRC
** Project management
*** COMMENT specific search =find-file-in-project=
#+BEGIN_SRC emacs-lisp :tangle yes
  ;; (use-package find-file-in-project)
#+END_SRC
*** =projectile
=
#+BEGIN_SRC emacs-lisp :tangle yes
  (use-package projectile
  :config (projectile-mode)
  :bind (:map projectile-mode-map ("C-c p" . projectile-command-map)))
#+END_SRC
